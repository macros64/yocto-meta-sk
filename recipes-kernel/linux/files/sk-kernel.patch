diff -urN fsl/arch/arm/boot/dts/imx6dl-hola-aeeb.dts sk/arch/arm/boot/dts/imx6dl-hola-aeeb.dts
--- fsl/arch/arm/boot/dts/imx6dl-hola-aeeb.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6dl-hola-aeeb.dts	2014-11-27 13:03:38.000000000 +0300
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6dl.dtsi"
+#include "imx6qdl-hola.dtsi"
+
+/ {
+	model = "Starterkit i.MX6 Solo Hola-PC Board with Additional Ethernet Extension Board";
+	compatible = "sk,imx6dl-hola", "fsl,imx6dl-sabresd", "fsl,imx6dl";
+
+	memory {
+		reg = <0x10000000 0x20000000>;
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&pcie {
+	reset-gpio = <&gpio2 14 0>;
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6dl-hola.dts sk/arch/arm/boot/dts/imx6dl-hola.dts
--- fsl/arch/arm/boot/dts/imx6dl-hola.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6dl-hola.dts	2014-10-24 21:56:06.000000000 +0400
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6dl.dtsi"
+#include "imx6qdl-hola.dtsi"
+
+/ {
+	model = "Starterkit i.MX6 Solo Hola-PC Board";
+	compatible = "sk,imx6dl-hola", "fsl,imx6dl-sabresd", "fsl,imx6dl";
+
+	memory {
+		reg = <0x10000000 0x20000000>;
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6dl-hola-feb.dts sk/arch/arm/boot/dts/imx6dl-hola-feb.dts
--- fsl/arch/arm/boot/dts/imx6dl-hola-feb.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6dl-hola-feb.dts	2014-10-26 02:11:16.000000000 +0300
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6dl.dtsi"
+#include "imx6qdl-hola.dtsi"
+
+/ {
+	model = "Starterkit i.MX6 Solo Hola-PC Board with FPGA Extension Board";
+	compatible = "sk,imx6dl-hola", "fsl,imx6dl-sabresd", "fsl,imx6dl";
+
+	memory {
+		reg = <0x10000000 0x20000000>;
+	};
+};
+
+&ecspi4 { /* spi1 */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi4_hola>;
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 20 0>;
+	status = "okay";
+
+	spi@0 {
+		compatible = "spidev";
+		reg = <0>;
+		spi-max-frequency = <1000000>;
+	};
+};
+
+&ecspi1 { /* spi2 */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_hola>;
+	fsl,spi-num-chipselects = <2>;
+	cs-gpios = <&gpio5 25 0>, <&gpio5 9 0>;
+	status = "okay";
+
+	spi@0 {
+		compatible = "spidev";
+		reg = <0>;
+		spi-max-frequency = <1000000>;
+	};
+
+	spi@1 {
+		compatible = "spidev";
+		reg = <1>;
+		spi-max-frequency = <1000000>;
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6dl-hola-ieb.dts sk/arch/arm/boot/dts/imx6dl-hola-ieb.dts
--- fsl/arch/arm/boot/dts/imx6dl-hola-ieb.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6dl-hola-ieb.dts	2014-11-27 13:12:28.000000000 +0300
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6dl.dtsi"
+#include "imx6qdl-hola.dtsi"
+
+/ {
+	model = "Starterkit i.MX6 Solo Hola-PC Board with Interfaces Extension Board";
+	compatible = "sk,imx6dl-hola", "fsl,imx6dl-sabresd", "fsl,imx6dl";
+
+	memory {
+		reg = <0x10000000 0x20000000>;
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-tlv320";
+		model = "imx-tlv320";
+		ssi-controller = <&ssi2>;
+		audio-codec = <&codec>;
+		audio-routing =
+			"MICIN", "Mic Jack",
+			"Headphone Jack", "LHPOUT",
+			"Headphone Jack", "RHPOUT";
+		mux-int-port = <2>;
+		mux-ext-port = <5>;
+	};
+
+	sound-spdif {
+		compatible = "fsl,imx-audio-spdif",
+				"fsl,imx-sabreauto-spdif";
+		model = "imx-spdif";
+		spdif-controller = <&spdif>;
+		spdif-out;
+	};
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux_hola>;
+	status = "okay";
+};
+
+&ecspi4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi4_hola>;
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 20 0>;
+	status = "okay";
+
+	tsc2046@0 {
+		compatible = "ti,tsc2046";
+		reg = <0>;
+		spi-max-frequency = <100000>;
+		/* pen irq is GPIO3_19 */
+		interrupt-parent = <&gpio3>;
+		interrupts = <19 0x2>;
+		pendown-gpio = <&gpio3 19 0>;
+		vcc-supply = <&reg_3p3v>;
+
+		ti,x-min = <150>;
+		ti,x-max = <3830>;
+		ti,y-min = <190>;
+		ti,y-max = <3830>;
+
+		linux,wakeup;
+	};
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2_hola>;
+	status = "okay";
+};
+
+&i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1_hola>;
+	clock-frequency = <100000>;
+	status = "okay";
+
+	codec: tlv320aic23@1a {
+		compatible = "ti,tlv320aic23";
+		reg = <0x1a>;
+		clocks = <&clks 200>;
+		clock-frequency = <12000000>;
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&pcie {
+	reset-gpio = <&gpio2 14 0>;
+	status = "okay";
+};
+
+&spdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_spdif_hola>;
+	status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-slave";
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_hola>;
+	cd-gpios = <&gpio1 8 0>;            /* pin conflict with uart2 */
+	vmmc-supply = <&reg_3p3v>;
+	no-1-8-v;
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6dl-hola-vceb.dts sk/arch/arm/boot/dts/imx6dl-hola-vceb.dts
--- fsl/arch/arm/boot/dts/imx6dl-hola-vceb.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6dl-hola-vceb.dts	2014-10-24 21:56:06.000000000 +0400
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6dl.dtsi"
+#include "imx6qdl-hola.dtsi"
+
+/ {
+	model = "Starterkit i.MX6 Solo Hola-PC Board with Video Capture Extension Board";
+	compatible = "sk,imx6dl-hola", "fsl,imx6dl-sabresd", "fsl,imx6dl";
+
+	memory {
+		reg = <0x10000000 0x20000000>;
+	};
+
+	v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		ain_num = <1>;
+		status = "okay";
+	};
+};
+
+&i2c3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3_hola>;
+	clock-frequency = <100000>;
+	status = "okay";
+
+	adv7180: adv7180@21 {
+		compatible = "adv,adv7180";
+		reg = <0x21>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_csi_hola>;
+		clocks = <&clks 201>;
+		clock-names = "csi_mclk";
+		DOVDD-supply = <&reg_3p3v>;
+		AVDD-supply = <&reg_3p3v>;
+		DVDD-supply = <&reg_3p3v>;
+		PVDD-supply = <&reg_3p3v>;
+		csi_id = <0>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+		cvbs = <1>;
+		cam_std = <0>; /* 0 - PAL(default), 1 - NTSC J , 2 - NTSC M */
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6dl-oem.dts sk/arch/arm/boot/dts/imx6dl-oem.dts
--- fsl/arch/arm/boot/dts/imx6dl-oem.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6dl-oem.dts	2014-10-24 21:56:06.000000000 +0400
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6dl.dtsi"
+#include "imx6qdl-oem.dtsi"
+
+/ {
+	model = "Starterkit SK-iMX6-OEM Board";
+	compatible = "sk,imx6dl-oem", "fsl,imx6dl-sabresd", "fsl,imx6dl";
+
+	memory {
+		reg = <0x10000000 0x20000000>;
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6dl-sodimm.dts sk/arch/arm/boot/dts/imx6dl-sodimm.dts
--- fsl/arch/arm/boot/dts/imx6dl-sodimm.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6dl-sodimm.dts	2014-10-24 21:56:06.000000000 +0400
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6dl.dtsi"
+#include "imx6qdl-sodimm.dtsi"
+
+/ {
+	model = "Starterkit SK-iMX6S-SODIMM Board";
+	compatible = "sk,imx6dl-sodimm", "fsl,imx6dl-sabresd", "fsl,imx6dl";
+
+	memory {
+		reg = <0x10000000 0x20000000>;
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6qdl.dtsi sk/arch/arm/boot/dts/imx6qdl.dtsi
--- fsl/arch/arm/boot/dts/imx6qdl.dtsi	2014-09-18 21:48:51.000000000 +0400
+++ sk/arch/arm/boot/dts/imx6qdl.dtsi	2014-12-09 11:34:16.000000000 +0300
@@ -836,6 +836,16 @@
 				status = "disabled";
 			};
 
+			usdhc3: usdhc@02198000 {
+				compatible = "fsl,imx6q-usdhc";
+				reg = <0x02198000 0x4000>;
+				interrupts = <0 24 0x04>;
+				clocks = <&clks 165>, <&clks 165>, <&clks 165>;
+				clock-names = "ipg", "ahb", "per";
+				bus-width = <4>;
+				status = "disabled";
+			};
+
 			usdhc1: usdhc@02190000 {
 				compatible = "fsl,imx6q-usdhc";
 				reg = <0x02190000 0x4000>;
@@ -854,16 +864,6 @@
 				clock-names = "ipg", "ahb", "per";
 				bus-width = <4>;
 				status = "disabled";
-			};
-
-			usdhc3: usdhc@02198000 {
-				compatible = "fsl,imx6q-usdhc";
-				reg = <0x02198000 0x4000>;
-				interrupts = <0 24 0x04>;
-				clocks = <&clks 165>, <&clks 165>, <&clks 165>;
-				clock-names = "ipg", "ahb", "per";
-				bus-width = <4>;
-				status = "disabled";
 			};
 
 			usdhc4: usdhc@0219c000 {
diff -urN fsl/arch/arm/boot/dts/imx6qdl-hola.dtsi sk/arch/arm/boot/dts/imx6qdl-hola.dtsi
--- fsl/arch/arm/boot/dts/imx6qdl-hola.dtsi	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6qdl-hola.dtsi	2014-10-28 21:49:29.000000000 +0300
@@ -0,0 +1,408 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/ {
+	aliases {
+		mxcfb0 = &mxcfb1;
+		mxcfb1 = &mxcfb2;
+	};
+
+	regulators {
+		compatible = "simple-bus";
+
+		reg_3p3v: 3p3v {
+			compatible = "regulator-fixed";
+			regulator-name = "3P3V";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+		
+		reg_usb_h1_vbus: usb_h1_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_h1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio7 7 0>;
+			enable-active-high;
+		};
+	};
+
+	mxcfb1: fb@0 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "hdmi";
+		interface_pix_fmt = "RGB24";
+		mode_str = "1280x720M@60";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb2: fb@1 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB24";
+		mode_str ="LDB-XGA";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx6q-audio-hdmi",
+			     "fsl,imx-audio-hdmi";
+		model = "imx-audio-hdmi";
+		hdmi-controller = <&hdmi_audio>;
+	};
+
+	v4l2_out {
+		compatible = "fsl,mxc_v4l2_output";
+		status = "okay";
+	};
+};
+
+&cpu0 {
+	arm-supply = <&reg_arm>;
+	soc-supply = <&reg_soc>;
+	pu-supply = <&reg_pu>;
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet_hola>;
+	phy-mode = "rmii";
+	phy-reset-gpios = <&gpio1 23 0>;
+	status = "okay";
+};
+
+&gpc {
+	fsl,cpu_pupscr_sw2iso = <0xf>;
+	fsl,cpu_pupscr_sw = <0xf>;
+	fsl,cpu_pdnscr_iso2sw = <0x1>;
+	fsl,cpu_pdnscr_iso = <0x1>;
+	fsl,ldo-bypass = <0>;
+	fsl,wdog-reset = <1>;
+	pu-supply = <&reg_pu>;
+};
+
+&gpu {
+	pu-supply = <&reg_pu>;
+};
+
+&hdmi_audio {
+	status = "okay";
+};
+
+&hdmi_cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_cec_hola>;
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <1>;
+	status = "okay";
+};
+
+&hdmi_video {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_hdcp_hola>;
+	fsl,phy_reg_vlev = <0x0294>;
+	fsl,phy_reg_cksymtx = <0x800d>;
+	fsl,hdcp;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	hog {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				/* AUDIO_MCLK */
+				MX6QDL_PAD_NANDF_CS2__CCM_CLKO2             0x80000000
+				/* SPI1 CS */
+				MX6QDL_PAD_EIM_D20__GPIO3_IO20              0x80000000
+				/* SPI2 CS0 */
+				MX6QDL_PAD_CSI0_DAT7__GPIO5_IO25            0x80000000
+				/* SPI2 CS1 */
+				MX6QDL_PAD_DISP0_DAT15__GPIO5_IO09          0x80000000
+				/* USB Host power */
+				MX6QDL_PAD_SD3_DAT3__GPIO7_IO07             0x80000000
+				/* SD1 CD */
+				MX6QDL_PAD_SD4_DAT1__GPIO2_IO09             0x80000000
+				/* SD1 VSELECT */
+				MX6QDL_PAD_KEY_COL1__SD1_VSELECT            0x17059
+				/* PHY Reset */
+				MX6QDL_PAD_ENET_REF_CLK__GPIO1_IO23         0x80000000
+				/* GPIO3_19 */
+				MX6QDL_PAD_EIM_D19__GPIO3_IO19              0x80000000
+				/* GPIO2_14 */
+				MX6QDL_PAD_SD4_DAT6__GPIO2_IO14             0x80000000
+				/* GPIO2_4 */
+				MX6QDL_PAD_NANDF_D4__GPIO2_IO04             0x80000000
+			>;
+		};
+	};
+
+	audmux {
+		pinctrl_audmux_hola: audmux-hola {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL0__AUD5_TXC               0x130b0
+				MX6QDL_PAD_KEY_ROW0__AUD5_TXD               0x130b0
+				MX6QDL_PAD_DISP0_DAT18__AUD5_TXFS           0x130b0
+				MX6QDL_PAD_KEY_ROW1__AUD5_RXD               0x130b0
+			>;
+		};
+	};
+
+	ecspi1 {
+		pinctrl_ecspi1_hola: ecspi1-hola {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT4__ECSPI1_SCLK           0x100b1
+				MX6QDL_PAD_CSI0_DAT5__ECSPI1_MOSI           0x100b1
+				MX6QDL_PAD_CSI0_DAT6__ECSPI1_MISO           0x100b1
+			>;
+		};
+	};
+
+	ecspi4 {
+		pinctrl_ecspi4_hola: ecspi4-hola {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D22__ECSPI4_MISO             0x100b1
+				MX6QDL_PAD_EIM_D28__ECSPI4_MOSI             0x100b1
+				MX6QDL_PAD_EIM_D21__ECSPI4_SCLK             0x100b1
+			>;
+		};
+	};
+
+	fec {
+		pinctrl_enet_hola: enet-hola {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK            0x4001b0a8
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO             0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC               0x1b0b0
+				MX6QDL_PAD_ENET_CRS_DV__ENET_RX_EN          0x1b0b0
+				MX6QDL_PAD_ENET_RX_ER__ENET_RX_ER           0x1b0b0
+				MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN           0x1b0b0
+				MX6QDL_PAD_ENET_RXD0__ENET_RX_DATA0         0x1b0b0
+				MX6QDL_PAD_ENET_RXD1__ENET_RX_DATA1         0x1b0b0
+				MX6QDL_PAD_ENET_TXD0__ENET_TX_DATA0         0x1b0b0
+				MX6QDL_PAD_ENET_TXD1__ENET_TX_DATA1         0x1b0b0
+			>;
+		};
+	};
+
+	flexcan2 {
+		pinctrl_flexcan2_hola: flexcan2-hola {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX            0x80000000
+				MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX            0x80000000
+			>;
+		};
+	};
+
+	hdmi_cec {
+		pinctrl_hdmi_cec_hola: hdmi-cec-hola {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE       0x1f8b0
+			>;
+		};
+	};
+
+	hdmi_hdcp {
+		pinctrl_hdmi_hdcp_hola: hdmi-hdcp-hola {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__HDMI_TX_DDC_SCL        0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__HDMI_TX_DDC_SDA        0x4001b8b1
+			>;
+		};
+	};
+
+	i2c1 {
+		pinctrl_i2c1_hola: i2c1-hola {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT8__I2C1_SDA              0x4001b8b1
+				MX6QDL_PAD_CSI0_DAT9__I2C1_SCL              0x4001b8b1
+			>;
+		};
+	};
+
+	i2c2 {
+		pinctrl_i2c2_hola: i2c2-hola {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB2__I2C2_SCL                0x4001b8b1
+				MX6QDL_PAD_EIM_D16__I2C2_SDA                0x4001b8b1
+			>;
+		};
+	};
+
+	i2c3 {
+		pinctrl_i2c3_hola: i2c3-hola {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D17__I2C3_SCL                0x4001b8b1
+				MX6QDL_PAD_EIM_D18__I2C3_SDA                0x4001b8b1
+			>;
+		};
+	};
+
+	ipu1 {
+		pinctrl_ipu1_csi_hola: ipu1-csi-hola {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__IPU1_CSI0_DATA12     0x80000000
+				MX6QDL_PAD_CSI0_DAT13__IPU1_CSI0_DATA13     0x80000000
+				MX6QDL_PAD_CSI0_DAT14__IPU1_CSI0_DATA14     0x80000000
+				MX6QDL_PAD_CSI0_DAT15__IPU1_CSI0_DATA15     0x80000000
+				MX6QDL_PAD_CSI0_DAT16__IPU1_CSI0_DATA16     0x80000000
+				MX6QDL_PAD_CSI0_DAT17__IPU1_CSI0_DATA17     0x80000000
+				MX6QDL_PAD_CSI0_DAT18__IPU1_CSI0_DATA18     0x80000000
+				MX6QDL_PAD_CSI0_DAT19__IPU1_CSI0_DATA19     0x80000000
+				MX6QDL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK    0x80000000
+				MX6QDL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC       0x80000000
+				MX6QDL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC      0x80000000
+			>;
+		};
+	};
+
+	pwm4 {
+		pinctrl_pwm4_hola: pwm4-hola {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_DAT2__PWM4_OUT               0x1b0b1
+			>;
+		};
+	};
+
+	spdif {
+		pinctrl_spdif_hola: spdif-hola {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_17__SPDIF_OUT               0x1b0b0
+			>;
+		};
+	};
+
+	uart1 {
+		pinctrl_uart1_hola: uart1-hola {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA        0x1b0b1
+				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA        0x1b0b1
+			>;
+		};
+	};
+
+	uart2 {
+		pinctrl_uart2_hola: uart2-hola {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_7__UART2_TX_DATA            0x1b0b1
+				MX6QDL_PAD_GPIO_8__UART2_RX_DATA            0x1b0b1
+			>;
+		};
+	};
+
+	usbotg {
+		pinctrl_usbotg_hola: usbotg-hola {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_1__USB_OTG_ID               0x17059
+			>;
+		};
+	};
+
+	usdhc1 {
+		pinctrl_usdhc1_hola: usdhc1-hola {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_CMD__SD1_CMD                 0x17059
+				MX6QDL_PAD_SD1_CLK__SD1_CLK                 0x17059
+				MX6QDL_PAD_SD1_DAT0__SD1_DATA0              0x17059
+				MX6QDL_PAD_SD1_DAT1__SD1_DATA1              0x17059
+				MX6QDL_PAD_SD1_DAT2__SD1_DATA2              0x17059
+				MX6QDL_PAD_SD1_DAT3__SD1_DATA3              0x17059
+			>;
+		};
+
+		pinctrl_usdhc1_hola_100mhz: usdhc1-hola-100mhz {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_CMD__SD1_CMD                 0x170B9
+				MX6QDL_PAD_SD1_CLK__SD1_CLK                 0x170B9
+				MX6QDL_PAD_SD1_DAT0__SD1_DATA0              0x170B9
+				MX6QDL_PAD_SD1_DAT1__SD1_DATA1              0x170B9
+				MX6QDL_PAD_SD1_DAT2__SD1_DATA2              0x170B9
+				MX6QDL_PAD_SD1_DAT3__SD1_DATA3              0x170B9
+			>;
+		};
+
+		pinctrl_usdhc1_hola_200mhz: usdhc1-hola-200mhz {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_CMD__SD1_CMD                 0x170F9
+				MX6QDL_PAD_SD1_CLK__SD1_CLK                 0x170F9
+				MX6QDL_PAD_SD1_DAT0__SD1_DATA0              0x170F9
+				MX6QDL_PAD_SD1_DAT1__SD1_DATA1              0x170F9
+				MX6QDL_PAD_SD1_DAT2__SD1_DATA2              0x170F9
+				MX6QDL_PAD_SD1_DAT3__SD1_DATA3              0x170F9
+			>;
+		};
+	};
+
+	usdhc2 {
+		pinctrl_usdhc2_hola: usdhc2-hola {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_CMD__SD2_CMD                 0x17059
+				MX6QDL_PAD_SD2_CLK__SD2_CLK                 0x10059
+				MX6QDL_PAD_SD2_DAT0__SD2_DATA0              0x17059
+				MX6QDL_PAD_SD2_DAT1__SD2_DATA1              0x17059
+				MX6QDL_PAD_SD2_DAT2__SD2_DATA2              0x17059
+				MX6QDL_PAD_SD2_DAT3__SD2_DATA3              0x17059
+				MX6QDL_PAD_GPIO_8__GPIO1_IO08               0x80000000
+			>;
+		};
+	};
+};
+
+&ldb {
+	ipu_id = <0>;
+	disp_id = <0>;
+	ext_ref = <1>;
+	mode = "sep0";
+	sec_ipu_id = <0>;
+	sec_disp_id = <1>;
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_hola>;
+	status = "okay";
+};
+
+&usbh1 {
+	vbus-supply = <&reg_usb_h1_vbus>;
+	status = "okay";
+};
+
+&usbotg {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_hola>;
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1_hola>;
+	pinctrl-1 = <&pinctrl_usdhc1_hola_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_hola_200mhz>;
+	cd-gpios = <&gpio2 9 0>;
+	vmmc-supply = <&reg_3p3v>;
+	keep-power-in-suspend;
+	status = "okay";
+};
+
+&vpu {
+	pu-supply = <&reg_pu>;
+};
diff -urN fsl/arch/arm/boot/dts/imx6qdl-oem.dtsi sk/arch/arm/boot/dts/imx6qdl-oem.dtsi
--- fsl/arch/arm/boot/dts/imx6qdl-oem.dtsi	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6qdl-oem.dtsi	2014-11-11 14:42:16.000000000 +0300
@@ -0,0 +1,634 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/ {
+	aliases {
+		mxcfb0 = &mxcfb1;
+		mxcfb1 = &mxcfb2;
+	};
+
+	backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+	};
+
+	regulators {
+		compatible = "simple-bus";
+
+		reg_3p3v: 3p3v {
+			compatible = "regulator-fixed";
+			regulator-name = "3P3V";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_usb_h1_vbus: usb_h1_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_h1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio7 7 0>;
+			enable-active-high;
+		};
+	};
+
+	mxcfb1: fb@0 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB24";
+		mode_str ="LDB-XGA";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb2: fb@1 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "hdmi";
+		interface_pix_fmt = "RGB24";
+		mode_str = "1280x720M@60";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	lcd@0 {
+		compatible = "fsl,lcd";
+		ipu_id = <0>;
+		disp_id = <0>;
+		default_ifmt = "RGB24";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_disp_oem>;
+		status = "okay";
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-tlv320";
+		model = "imx-tlv320";
+		ssi-controller = <&ssi2>;
+		audio-codec = <&codec>;
+		audio-routing =
+			"MICIN", "Mic Jack",
+			"Headphone Jack", "LHPOUT",
+			"Headphone Jack", "RHPOUT";
+		mux-int-port = <2>;
+		mux-ext-port = <5>;
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx6q-audio-hdmi",
+			     "fsl,imx-audio-hdmi";
+		model = "imx-audio-hdmi";
+		hdmi-controller = <&hdmi_audio>;
+	};
+
+	sound-spdif {
+		compatible = "fsl,imx-audio-spdif",
+				"fsl,imx-sabreauto-spdif";
+		model = "imx-spdif";
+		spdif-controller = <&spdif>;
+		spdif-out;
+	};
+
+	v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		ain_num = <1>;
+		status = "okay";
+	};
+	
+	v4l2_out {
+		compatible = "fsl,mxc_v4l2_output";
+		status = "okay";
+	};
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux_oem>;
+	status = "okay";
+};
+
+&cpu0 {
+	arm-supply = <&reg_arm>;
+	soc-supply = <&reg_soc>;
+	pu-supply = <&reg_pu>;
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio5 25 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_oem>;
+	status = "okay";
+
+	tsc2046@0 {
+		compatible = "ti,tsc2046";
+		reg = <0>;
+		spi-max-frequency = <100000>;
+		/* pen irq is GPIO4_15 */
+		interrupt-parent = <&gpio4>;
+		interrupts = <15 0x2>;
+		pendown-gpio = <&gpio4 15 0>;
+		vcc-supply = <&reg_3p3v>;
+
+		ti,x-min = <150>;
+		ti,x-max = <3830>;
+		ti,y-min = <190>;
+		ti,y-max = <3830>;
+
+		linux,wakeup;
+	};
+};
+
+&ecspi4 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 20 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi4_oem>;
+	status = "okay";
+
+	tsc2046@0 {
+		compatible = "ti,tsc2046";
+		reg = <0>;
+		spi-max-frequency = <100000>;
+		/* pen irq is GPIO1_9 */
+		interrupt-parent = <&gpio1>;
+		interrupts = <9 0x2>;
+		pendown-gpio = <&gpio1 9 0>;
+		vcc-supply = <&reg_3p3v>;
+
+		ti,x-min = <150>;
+		ti,x-max = <3830>;
+		ti,y-min = <190>;
+		ti,y-max = <3830>;
+
+		linux,wakeup;
+	};
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet_oem>;
+	phy-mode = "rmii";
+	phy-reset-gpios = <&gpio1 23 0>;
+	status = "okay";
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1_oem>;
+	status = "okay";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2_oem>;
+	status = "okay";
+};
+
+&gpc {
+	fsl,cpu_pupscr_sw2iso = <0xf>;
+	fsl,cpu_pupscr_sw = <0xf>;
+	fsl,cpu_pdnscr_iso2sw = <0x1>;
+	fsl,cpu_pdnscr_iso = <0x1>;
+	fsl,ldo-bypass = <0>;
+	fsl,wdog-reset = <1>;
+	pu-supply = <&reg_pu>;
+};
+
+&gpmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpmi_nand_oem>;
+	nand-on-flash-bbt;
+	status = "okay";
+};
+
+&gpu {
+	pu-supply = <&reg_pu>;
+};
+
+&hdmi_audio {
+	status = "okay";
+};
+
+&hdmi_cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_cec_oem>;
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <1>;
+	status = "okay";
+};
+
+&hdmi_video {
+	fsl,phy_reg_vlev = <0x0294>;
+	fsl,phy_reg_cksymtx = <0x800d>;
+	status = "okay";
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_oem>;
+	status = "okay";
+
+	codec: tlv320aic23@1a {
+		compatible = "ti,tlv320aic23";
+		reg = <0x1a>;
+		clocks = <&clks 200>;
+		clock-frequency = <12000000>;
+	};
+
+	adv7180: adv7180@21 {
+		compatible = "adv,adv7180";
+		reg = <0x21>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_csi_oem>;
+		clocks = <&clks 201>;
+		clock-names = "csi_mclk";
+		DOVDD-supply = <&reg_3p3v>;
+		AVDD-supply = <&reg_3p3v>;
+		DVDD-supply = <&reg_3p3v>;
+		PVDD-supply = <&reg_3p3v>;
+		csi_id = <0>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+		cvbs = <1>;
+		cam_std = <0>; /* 0 - PAL(default), 1 - NTSC J , 2 - NTSC M */
+	};
+	
+	hdmi: edid@50 {
+		compatible = "fsl,imx6-hdmi-i2c";
+		reg = <0x50>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	hog {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				/* AUDIO_MCLK */
+				MX6QDL_PAD_NANDF_CS2__CCM_CLKO2             0x80000000
+				/* ECSPI1 CS0 */
+				MX6QDL_PAD_CSI0_DAT7__GPIO5_IO25            0x80000000
+				/* ECSPI4 CS0 */
+				MX6QDL_PAD_EIM_D20__GPIO3_IO20              0x80000000
+				/* LVDS0 TS PENIRQ */
+				MX6QDL_PAD_GPIO_9__GPIO1_IO09               0x80000000
+				/* LVDS1 TS PENIRQ */
+				MX6QDL_PAD_KEY_ROW4__GPIO4_IO15             0x80000000
+				/* PHY Reset */
+				MX6QDL_PAD_ENET_REF_CLK__GPIO1_IO23         0x80000000
+				/* SD1 CD */
+				MX6QDL_PAD_SD4_DAT1__GPIO2_IO09             0x80000000
+				/* SD2_DET */
+				MX6QDL_PAD_SD4_DAT3__GPIO2_IO11             0x80000000
+				/* USB Host power */
+				MX6QDL_PAD_SD3_DAT3__GPIO7_IO07             0x80000000
+			>;
+		};
+	};
+
+	audmux {
+		pinctrl_audmux_oem: audmux-oem {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL0__AUD5_TXC               0x130b0
+				MX6QDL_PAD_KEY_ROW0__AUD5_TXD               0x130b0
+				MX6QDL_PAD_KEY_COL1__AUD5_TXFS              0x130b0
+				MX6QDL_PAD_KEY_ROW1__AUD5_RXD               0x130b0
+			>;
+		};
+	};
+
+	ecspi1 {
+		pinctrl_ecspi1_oem: ecspi1-oem {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT4__ECSPI1_SCLK           0x100b1
+				MX6QDL_PAD_CSI0_DAT5__ECSPI1_MOSI           0x100b1
+				MX6QDL_PAD_CSI0_DAT6__ECSPI1_MISO           0x100b1
+			>;
+		};
+	};
+
+	ecspi4 {
+		pinctrl_ecspi4_oem: ecspi4-oem {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D21__ECSPI4_SCLK             0x100b1
+				MX6QDL_PAD_EIM_D22__ECSPI4_MISO             0x100b1
+				MX6QDL_PAD_EIM_D28__ECSPI4_MOSI             0x100b1
+			>;
+		};
+	};
+
+	fec {
+		pinctrl_enet_oem: enet-oem {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK            0x4001b0a8
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO             0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC               0x1b0b0
+				MX6QDL_PAD_ENET_CRS_DV__ENET_RX_EN          0x1b0b0
+				MX6QDL_PAD_ENET_RX_ER__ENET_RX_ER           0x1b0b0
+				MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN           0x1b0b0
+				MX6QDL_PAD_ENET_RXD0__ENET_RX_DATA0         0x1b0b0
+				MX6QDL_PAD_ENET_RXD1__ENET_RX_DATA1         0x1b0b0
+				MX6QDL_PAD_ENET_TXD0__ENET_TX_DATA0         0x1b0b0
+				MX6QDL_PAD_ENET_TXD1__ENET_TX_DATA1         0x1b0b0
+			>;
+		};
+	};
+
+	flexcan1 {
+		pinctrl_flexcan1_oem: flexcan1-oem {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CLK__FLEXCAN1_RX             0x80000000
+				MX6QDL_PAD_SD3_CMD__FLEXCAN1_TX             0x80000000
+			>;
+		};
+	};
+
+	flexcan2 {
+		pinctrl_flexcan2_oem: flexcan2-oem {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_DAT1__FLEXCAN2_RX            0x80000000
+				MX6QDL_PAD_SD3_DAT0__FLEXCAN2_TX            0x80000000
+			>;
+		};
+	};
+
+	gpmi-nand {
+		pinctrl_gpmi_nand_oem: gpmi-nand-oem {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CLE__NAND_CLE              0xb0b1
+				MX6QDL_PAD_NANDF_ALE__NAND_ALE              0xb0b1
+				MX6QDL_PAD_NANDF_WP_B__NAND_WP_B            0xb0b1
+				MX6QDL_PAD_NANDF_RB0__NAND_READY_B          0xb000
+				MX6QDL_PAD_NANDF_CS0__NAND_CE0_B            0xb0b1
+				MX6QDL_PAD_NANDF_CS1__NAND_CE1_B            0xb0b1
+				MX6QDL_PAD_SD4_CMD__NAND_RE_B               0xb0b1
+				MX6QDL_PAD_SD4_CLK__NAND_WE_B               0xb0b1
+				MX6QDL_PAD_NANDF_D0__NAND_DATA00            0xb0b1
+				MX6QDL_PAD_NANDF_D1__NAND_DATA01            0xb0b1
+				MX6QDL_PAD_NANDF_D2__NAND_DATA02            0xb0b1
+				MX6QDL_PAD_NANDF_D3__NAND_DATA03            0xb0b1
+				MX6QDL_PAD_NANDF_D4__NAND_DATA04            0xb0b1
+				MX6QDL_PAD_NANDF_D5__NAND_DATA05            0xb0b1
+				MX6QDL_PAD_NANDF_D6__NAND_DATA06            0xb0b1
+				MX6QDL_PAD_NANDF_D7__NAND_DATA07            0xb0b1
+				MX6QDL_PAD_SD4_DAT0__NAND_DQS               0x00b1
+			>;
+		};
+	};
+
+	hdmi_cec {
+		pinctrl_hdmi_cec_oem: hdmi-cec-oem {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE       0x1f8b0
+			>;
+		};
+	};
+
+	i2c2 {
+		pinctrl_i2c2_oem: i2c2-oem {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB2__I2C2_SCL                0x4001b8b1
+				MX6QDL_PAD_EIM_D16__I2C2_SDA                0x4001b8b1
+			>;
+		};
+	};
+
+	i2c3 {
+		pinctrl_i2c3_oem: i2c3-oem {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D17__I2C3_SCL                0x4001b8b1
+				MX6QDL_PAD_EIM_D18__I2C3_SDA                0x4001b8b1
+			>;
+		};
+	};
+
+	ipu1 {
+		pinctrl_ipu1_csi_oem: ipu1-csi-oem {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__IPU1_CSI0_DATA12     0x80000000
+				MX6QDL_PAD_CSI0_DAT13__IPU1_CSI0_DATA13     0x80000000
+				MX6QDL_PAD_CSI0_DAT14__IPU1_CSI0_DATA14     0x80000000
+				MX6QDL_PAD_CSI0_DAT15__IPU1_CSI0_DATA15     0x80000000
+				MX6QDL_PAD_CSI0_DAT16__IPU1_CSI0_DATA16     0x80000000
+				MX6QDL_PAD_CSI0_DAT17__IPU1_CSI0_DATA17     0x80000000
+				MX6QDL_PAD_CSI0_DAT18__IPU1_CSI0_DATA18     0x80000000
+				MX6QDL_PAD_CSI0_DAT19__IPU1_CSI0_DATA19     0x80000000
+				MX6QDL_PAD_CSI0_DATA_EN__IPU1_CSI0_DATA_EN  0x80000000
+				MX6QDL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK    0x80000000
+				MX6QDL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC       0x80000000
+				MX6QDL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC      0x80000000
+			>;
+		};
+
+		pinctrl_ipu1_disp_oem: ipu1-disp-oem {
+			fsl,pins = <
+				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK  0x10
+				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15        0x10
+				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02         0x10
+				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03         0x10
+				MX6QDL_PAD_DI0_PIN4__IPU1_DI0_PIN04         0x80000000
+				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00    0x10
+				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01    0x10
+				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02    0x10
+				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03    0x10
+				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04    0x10
+				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05    0x10
+				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06    0x10
+				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07    0x10
+				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08    0x10
+				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09    0x10
+				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10   0x10
+				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11   0x10
+				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12   0x10
+				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13   0x10
+				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14   0x10
+				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15   0x10
+				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16   0x10
+				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17   0x10
+				MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18   0x10
+				MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19   0x10
+				MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20   0x10
+				MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21   0x10
+				MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22   0x10
+				MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23   0x10
+			>;
+		};
+	};
+
+	pwm1 {
+		pinctrl_pwm1_oem: pwm1-oem {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_9__PWM1_OUT                 0x1b0b1
+			>;
+		};
+	};
+
+	pwm4 {
+		pinctrl_pwm4_oem: pwm4-oem {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_DAT2__PWM4_OUT               0x1b0b1
+			>;
+		};
+	};
+
+	spdif {
+		pinctrl_spdif_oem: spdif-oem {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_17__SPDIF_OUT               0x1b0b0
+			>;
+		};
+	};
+
+	uart1 {
+		pinctrl_uart1_oem: uart1-oem {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA        0x1b0b1
+				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA        0x1b0b1
+			>;
+		};
+	};
+
+	uart2 {
+		pinctrl_uart2_oem: uart2-oem {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_7__UART2_TX_DATA            0x1b0b1
+				MX6QDL_PAD_GPIO_8__UART2_RX_DATA            0x1b0b1
+			>;
+		};
+	};
+
+	usbotg {
+		pinctrl_usbotg_oem: usbotg-oem {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_1__USB_OTG_ID               0x17059
+			>;
+		};
+	};
+
+	usdhc1 {
+		pinctrl_usdhc1_oem: usdhc1-oem {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_CMD__SD1_CMD                 0x17059
+				MX6QDL_PAD_SD1_CLK__SD1_CLK                 0x10059
+				MX6QDL_PAD_SD1_DAT0__SD1_DATA0              0x17059
+				MX6QDL_PAD_SD1_DAT1__SD1_DATA1              0x17059
+				MX6QDL_PAD_SD1_DAT2__SD1_DATA2              0x17059
+				MX6QDL_PAD_SD1_DAT3__SD1_DATA3              0x17059
+			>;
+		};
+	};
+
+	usdhc2 {
+		pinctrl_usdhc2_oem: usdhc2-oem {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_CMD__SD2_CMD                 0x17059
+				MX6QDL_PAD_SD2_CLK__SD2_CLK                 0x10059
+				MX6QDL_PAD_SD2_DAT0__SD2_DATA0              0x17059
+				MX6QDL_PAD_SD2_DAT1__SD2_DATA1              0x17059
+				MX6QDL_PAD_SD2_DAT2__SD2_DATA2              0x17059
+				MX6QDL_PAD_SD2_DAT3__SD2_DATA3              0x17059
+			>;
+		};
+	};
+};
+
+&ldb {
+	ipu_id = <0>;
+	disp_id = <0>;
+	ext_ref = <1>;
+	mode = "sep0";
+	sec_ipu_id = <0>;
+	sec_disp_id = <1>;
+	status = "okay";
+};
+
+&pcie {
+	status = "okay";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm4_oem>;
+	status = "okay";
+};
+
+&spdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_spdif_oem>;
+	status = "disabled";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-slave";
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_oem>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2_oem>;
+	status = "okay";
+};
+
+&usbh1 {
+	vbus-supply = <&reg_usb_h1_vbus>;
+	status = "okay";
+};
+
+&usbotg {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_oem>;
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc1_oem>;
+	cd-gpios = <&gpio2 9 0>;
+	vmmc-supply = <&reg_3p3v>;
+	keep-power-in-suspend;
+	no-1-8-v;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_oem>;
+	cd-gpios = <&gpio2 11 0>;
+	vmmc-supply = <&reg_3p3v>;
+	keep-power-in-suspend;
+	no-1-8-v;
+	status = "okay";
+};
+
+&vpu {
+	pu-supply = <&reg_pu>;
+};
+
diff -urN fsl/arch/arm/boot/dts/imx6qdl-sk.dtsi sk/arch/arm/boot/dts/imx6qdl-sk.dtsi
--- fsl/arch/arm/boot/dts/imx6qdl-sk.dtsi	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6qdl-sk.dtsi	2014-11-16 19:42:25.000000000 +0300
@@ -0,0 +1,684 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/ {
+	aliases {
+		mxcfb0 = &mxcfb1;
+		mxcfb1 = &mxcfb2;
+		mxcfb2 = &mxcfb3;
+		mxcfb3 = &mxcfb4;
+	};
+
+	regulators {
+		compatible = "simple-bus";
+
+		reg_3p3v: 3p3v {
+			compatible = "regulator-fixed";
+			regulator-name = "3P3V";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_usb_otg_vbus: usb_otg_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio1 28 0>;
+			enable-active-high;
+		};
+	};
+
+	mxcfb1: fb@0 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB24";
+		mode_str ="LDB-XGA";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb2: fb@1 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "hdmi";
+		interface_pix_fmt = "RGB24";
+		mode_str ="1920x1080M@60";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb3: fb@2 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB24";
+		mode_str ="CLAA-WVGA";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb4: fb@3 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB24";
+		mode_str ="LDB-XGA";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	lcd@0 {
+		compatible = "fsl,lcd";
+		ipu_id = <0>;
+		disp_id = <0>;
+		default_ifmt = "RGB24";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_disp_sk>;
+		status = "okay";
+	};
+
+	spi_lcd {
+		compatible = "spi-gpio";
+		gpio-sck = <&gpio1 1 0>;
+		gpio-miso = <&gpio7 11 0>;
+		gpio-mosi = <&gpio1 2 0>;
+		cs-gpios = <&gpio4 15 0>;
+		num-chipselects = <1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+
+		tsc2046@0 {
+			compatible = "ti,tsc2046";
+			reg = <0>;
+			spi-max-frequency = <100000>;
+			/* pen irq is GPIO1_8 */
+			interrupt-parent = <&gpio1>;
+			interrupts = <8 0x2>;
+			pendown-gpio = <&gpio1 8 0>;
+			vcc-supply = <&reg_3p3v>;
+
+			ti,x-min = <150>;
+			ti,x-max = <3830>;
+			ti,y-min = <190>;
+			ti,y-max = <3830>;
+
+			linux,wakeup;
+		};
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-tlv320";
+		model = "imx-tlv320";
+		ssi-controller = <&ssi2>;
+		audio-codec = <&codec>;
+		audio-routing =
+			"MICIN", "Mic Jack",
+			"Headphone Jack", "LHPOUT",
+			"Headphone Jack", "RHPOUT";
+		mux-int-port = <2>;
+		mux-ext-port = <5>;
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx6q-audio-hdmi",
+			     "fsl,imx-audio-hdmi";
+		model = "imx-audio-hdmi";
+		hdmi-controller = <&hdmi_audio>;
+	};
+
+	sound-spdif {
+		compatible = "fsl,imx-audio-spdif",
+				"fsl,imx-sabreauto-spdif";
+		model = "imx-spdif";
+		spdif-controller = <&spdif>;
+		spdif-out;
+	};
+
+	v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		ain_num = <1>;
+		status = "okay";
+	};
+
+	v4l2_out {
+		compatible = "fsl,mxc_v4l2_output";
+		status = "okay";
+	};
+};
+
+&audmux {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux_sk>;
+};
+
+&cpu0 {
+	arm-supply = <&reg_arm>;
+	soc-supply = <&reg_soc>;
+	pu-supply = <&reg_pu>;
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio5 25 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_sk>;
+	status = "okay";
+
+	tsc2046@0 {
+		compatible = "ti,tsc2046";
+		reg = <0>;
+		spi-max-frequency = <100000>;
+		/* pen irq is GPIO1_7 */
+		interrupt-parent = <&gpio1>;
+		interrupts = <7 0x2>;
+		pendown-gpio = <&gpio1 7 0>;
+		vcc-supply = <&reg_3p3v>;
+
+		ti,x-min = <150>;
+		ti,x-max = <3830>;
+		ti,y-min = <190>;
+		ti,y-max = <3830>;
+
+		linux,wakeup;
+	};
+};
+
+&ecspi4 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 29 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi4_sk>;
+	status = "disabled";
+
+	tsc2046@0 {
+		compatible = "ti,tsc2046";
+		reg = <0>;
+		spi-max-frequency = <100000>;
+		/* pen irq is GPIO4_10 */
+		interrupt-parent = <&gpio4>;
+		interrupts = <10 0x2>;
+		pendown-gpio = <&gpio4 10 0>;
+		vcc-supply = <&reg_3p3v>;
+
+		ti,x-min = <150>;
+		ti,x-max = <3830>;
+		ti,y-min = <190>;
+		ti,y-max = <3830>;
+
+		linux,wakeup;
+	};
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet_sk>;
+	phy-mode = "rgmii";
+	phy-reset-gpios = <&gpio1 25 0>;
+	status = "okay";
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1_sk>;
+	status = "okay";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2_sk>;
+	status = "okay";
+};
+
+&gpc {
+	fsl,cpu_pupscr_sw2iso = <0xf>;
+	fsl,cpu_pupscr_sw = <0xf>;
+	fsl,cpu_pdnscr_iso2sw = <0x1>;
+	fsl,cpu_pdnscr_iso = <0x1>;
+	fsl,ldo-bypass = <0>;
+	fsl,wdog-reset = <1>;
+	pu-supply = <&reg_pu>;
+};
+
+&gpmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpmi_nand_sk>;
+	nand-on-flash-bbt;
+	status = "okay";
+};
+
+&gpu {
+	pu-supply = <&reg_pu>;
+};
+
+&hdmi_audio {
+	status = "okay";
+};
+
+&hdmi_cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_cec_sk>;
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <1>;
+	status = "okay";
+};
+
+&hdmi_video {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_hdcp_sk>;
+	fsl,phy_reg_vlev = <0x0294>;
+	fsl,phy_reg_cksymtx = <0x800d>;
+	fsl,hdcp;
+	status = "okay";
+};
+
+&i2c1 {
+	status = "okay";
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1_sk>;
+
+	codec: tlv320aic23@1a {
+		compatible = "ti,tlv320aic23";
+		reg = <0x1a>;
+		clocks = <&clks 200>;
+		clock-frequency = <12000000>;
+	};
+
+	adv7180: adv7180@21 {
+		compatible = "adv,adv7180";
+		reg = <0x21>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_csi_sk>;
+		clocks = <&clks 201>;
+		clock-names = "csi_mclk";
+		DOVDD-supply = <&reg_3p3v>;
+		AVDD-supply = <&reg_3p3v>;
+		DVDD-supply = <&reg_3p3v>;
+		PVDD-supply = <&reg_3p3v>;
+		pwn-gpios = <&gpio7 6 0>;
+		csi_id = <0>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+		cvbs = <1>;
+	};
+};
+
+/*
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_sk>;
+	status = "okay";
+
+	hdmi: edid@50 {
+		compatible = "fsl,imx6-hdmi-i2c";
+		reg = <0x50>;
+	};
+};
+*/
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	hog {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				/* SD1_DET */
+				MX6QDL_PAD_SD4_DAT1__GPIO2_IO09             0x80000000
+				/* SD2_DET */
+				MX6QDL_PAD_SD4_DAT3__GPIO2_IO11             0x80000000
+				/* LVDS0 TS-CS */
+				MX6QDL_PAD_CSI0_DAT7__GPIO5_IO25            0x80000000
+				/* LVDS0 TS-PENIRQ */
+				MX6QDL_PAD_GPIO_7__GPIO1_IO07               0x80000000
+				/* LVDS1 TS-CS */
+				MX6QDL_PAD_EIM_D29__GPIO3_IO29              0x80000000
+				/* LVDS1 TS-PENIRQ */
+				MX6QDL_PAD_KEY_COL2__GPIO4_IO10             0x80000000
+				/* LCD-SPI CLK */
+				MX6QDL_PAD_GPIO_1__GPIO1_IO01               0x80000000
+				/* LCD-SPI MISO */
+				MX6QDL_PAD_GPIO_16__GPIO7_IO11              0x80000000
+				/* LCD-SPI MOSI */
+				MX6QDL_PAD_GPIO_2__GPIO1_IO02               0x80000000
+				/* LCD-SPI TS-CS */
+				MX6QDL_PAD_KEY_ROW4__GPIO4_IO15             0x80000000
+				/* LCD-SPI TS-PENIRQ */
+				MX6QDL_PAD_GPIO_8__GPIO1_IO08               0x80000000
+				/* ETH_RESET */
+				MX6QDL_PAD_ENET_CRS_DV__GPIO1_IO25          0x80000000
+				/* AUDIO_MCLK */
+				MX6QDL_PAD_NANDF_CS2__CCM_CLKO2             0x80000000
+				/* USB0_PWR */
+				MX6QDL_PAD_ENET_TX_EN__GPIO1_IO28           0x80000000
+				/* CSI PD */
+				MX6QDL_PAD_SD3_DAT2__GPIO7_IO06             0x80000000
+			>;
+		};
+	};
+
+	audmux {
+		pinctrl_audmux_sk: audmux-sk {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL0__AUD5_TXC               0x130b0
+				MX6QDL_PAD_KEY_ROW0__AUD5_TXD               0x130b0
+				MX6QDL_PAD_KEY_COL1__AUD5_TXFS              0x130b0
+				MX6QDL_PAD_KEY_ROW1__AUD5_RXD               0x130b0
+			>;
+		};
+	};
+
+	ecspi1 {
+		pinctrl_ecspi1_sk: ecspi1-sk {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT4__ECSPI1_SCLK           0x100b1
+				MX6QDL_PAD_CSI0_DAT5__ECSPI1_MOSI           0x100b1
+				MX6QDL_PAD_CSI0_DAT6__ECSPI1_MISO           0x100b1
+			>;
+		};
+	};
+
+	ecspi4 {
+		pinctrl_ecspi4_sk: ecspi4-sk {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D22__ECSPI4_MISO             0x100b1
+				MX6QDL_PAD_EIM_D28__ECSPI4_MOSI             0x100b1
+				MX6QDL_PAD_EIM_D21__ECSPI4_SCLK             0x100b1
+			>;
+		};
+	};
+
+	enet {
+		pinctrl_enet_sk: enet-sk {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO             0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC               0x1b0b0
+				MX6QDL_PAD_RGMII_TXC__RGMII_TXC             0x1b0b0
+				MX6QDL_PAD_RGMII_TD0__RGMII_TD0             0x1b0b0
+				MX6QDL_PAD_RGMII_TD1__RGMII_TD1             0x1b0b0
+				MX6QDL_PAD_RGMII_TD2__RGMII_TD2             0x1b0b0
+				MX6QDL_PAD_RGMII_TD3__RGMII_TD3             0x1b0b0
+				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL       0x1b0b0
+				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK        0x1b0b0
+				MX6QDL_PAD_RGMII_RXC__RGMII_RXC             0x1b0b0
+				MX6QDL_PAD_RGMII_RD0__RGMII_RD0             0x1b0b0
+				MX6QDL_PAD_RGMII_RD1__RGMII_RD1             0x1b0b0
+				MX6QDL_PAD_RGMII_RD2__RGMII_RD2             0x1b0b0
+				MX6QDL_PAD_RGMII_RD3__RGMII_RD3             0x1b0b0
+				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL       0x1b0b0
+			>;
+		};
+	};
+
+	flexcan1 {
+		pinctrl_flexcan1_sk: flexcan1-sk {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CLK__FLEXCAN1_RX             0x80000000
+				MX6QDL_PAD_SD3_CMD__FLEXCAN1_TX             0x80000000
+			>;
+		};
+	};
+
+	flexcan2 {
+		pinctrl_flexcan2_sk: flexcan2-sk {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_DAT1__FLEXCAN2_RX            0x80000000
+				MX6QDL_PAD_SD3_DAT0__FLEXCAN2_TX            0x80000000
+			>;
+		};
+	};
+
+	gpmi-nand {
+		pinctrl_gpmi_nand_sk: gpmi-nand-sk {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CLE__NAND_CLE              0xb0b1
+				MX6QDL_PAD_NANDF_ALE__NAND_ALE              0xb0b1
+				MX6QDL_PAD_NANDF_WP_B__NAND_WP_B            0xb0b1
+				MX6QDL_PAD_NANDF_RB0__NAND_READY_B          0xb000
+				MX6QDL_PAD_NANDF_CS0__NAND_CE0_B            0xb0b1
+				MX6QDL_PAD_NANDF_CS1__NAND_CE1_B            0xb0b1
+				MX6QDL_PAD_SD4_CMD__NAND_RE_B               0xb0b1
+				MX6QDL_PAD_SD4_CLK__NAND_WE_B               0xb0b1
+				MX6QDL_PAD_NANDF_D0__NAND_DATA00            0xb0b1
+				MX6QDL_PAD_NANDF_D1__NAND_DATA01            0xb0b1
+				MX6QDL_PAD_NANDF_D2__NAND_DATA02            0xb0b1
+				MX6QDL_PAD_NANDF_D3__NAND_DATA03            0xb0b1
+				MX6QDL_PAD_NANDF_D4__NAND_DATA04            0xb0b1
+				MX6QDL_PAD_NANDF_D5__NAND_DATA05            0xb0b1
+				MX6QDL_PAD_NANDF_D6__NAND_DATA06            0xb0b1
+				MX6QDL_PAD_NANDF_D7__NAND_DATA07            0xb0b1
+				MX6QDL_PAD_SD4_DAT0__NAND_DQS               0x00b1
+			>;
+		};
+	};
+
+	hdmi_cec {
+		pinctrl_hdmi_cec_sk: hdmi-cec-sk {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE       0x1f8b0
+			>;
+		};
+	};
+
+	hdmi_hdcp {
+		pinctrl_hdmi_hdcp_sk: hdmi-hdcp-sk {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__HDMI_TX_DDC_SCL        0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__HDMI_TX_DDC_SDA        0x4001b8b1
+			>;
+		};
+	};
+
+	i2c1 {
+		pinctrl_i2c1_sk: i2c1-sk {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT8__I2C1_SDA              0x4001b8b1
+				MX6QDL_PAD_CSI0_DAT9__I2C1_SCL              0x4001b8b1
+			>;
+		};
+	};
+
+	i2c2 {
+		pinctrl_i2c2_sk: i2c2-sk {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__I2C2_SCL               0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA               0x4001b8b1
+			>;
+		};
+	};
+
+	ipu1 {
+		pinctrl_ipu1_csi_sk: ipu1-csi-sk {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__IPU1_CSI0_DATA12     0x80000000
+				MX6QDL_PAD_CSI0_DAT13__IPU1_CSI0_DATA13     0x80000000
+				MX6QDL_PAD_CSI0_DAT14__IPU1_CSI0_DATA14     0x80000000
+				MX6QDL_PAD_CSI0_DAT15__IPU1_CSI0_DATA15     0x80000000
+				MX6QDL_PAD_CSI0_DAT16__IPU1_CSI0_DATA16     0x80000000
+				MX6QDL_PAD_CSI0_DAT17__IPU1_CSI0_DATA17     0x80000000
+				MX6QDL_PAD_CSI0_DAT18__IPU1_CSI0_DATA18     0x80000000
+				MX6QDL_PAD_CSI0_DAT19__IPU1_CSI0_DATA19     0x80000000
+				MX6QDL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK    0x80000000
+				MX6QDL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC       0x80000000
+				MX6QDL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC      0x80000000
+			>;
+		};
+
+		pinctrl_ipu1_disp_sk: ipu1-disp-sk {
+			fsl,pins = <
+				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK  0x10
+				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15        0x10
+				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02         0x10
+				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03         0x10
+				MX6QDL_PAD_DI0_PIN4__IPU1_DI0_PIN04         0x80000000
+				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00    0x10
+				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01    0x10
+				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02    0x10
+				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03    0x10
+				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04    0x10
+				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05    0x10
+				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06    0x10
+				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07    0x10
+				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08    0x10
+				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09    0x10
+				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10   0x10
+				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11   0x10
+				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12   0x10
+				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13   0x10
+				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14   0x10
+				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15   0x10
+				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16   0x10
+				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17   0x10
+				MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18   0x10
+				MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19   0x10
+				MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20   0x10
+				MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21   0x10
+				MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22   0x10
+				MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23   0x10
+			>;
+		};
+	};
+
+	spdif {
+		pinctrl_spdif_sk: spdif-sk {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_17__SPDIF_OUT               0x1b0b0
+			>;
+		};
+	};
+
+	uart1 {
+		pinctrl_uart1_sk: uart1-sk {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA        0x1b0b1
+				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA        0x1b0b1
+			>;
+		};
+	};
+
+	usbotg {
+		pinctrl_usbotg_sk: usbotg-sk {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_RX_ER__USB_OTG_ID           0x17059
+			>;
+		};
+	};
+
+	usdhc1 {
+		pinctrl_usdhc1_sk: usdhc1-sk {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_CMD__SD1_CMD                 0x17059
+				MX6QDL_PAD_SD1_CLK__SD1_CLK                 0x10059
+				MX6QDL_PAD_SD1_DAT0__SD1_DATA0              0x17059
+				MX6QDL_PAD_SD1_DAT1__SD1_DATA1              0x17059
+				MX6QDL_PAD_SD1_DAT2__SD1_DATA2              0x17059
+				MX6QDL_PAD_SD1_DAT3__SD1_DATA3              0x17059
+			>;
+		};
+	};
+
+	usdhc2 {
+		pinctrl_usdhc2_sk: usdhc2-sk {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_CMD__SD2_CMD                 0x17059
+				MX6QDL_PAD_SD2_CLK__SD2_CLK                 0x10059
+				MX6QDL_PAD_SD2_DAT0__SD2_DATA0              0x17059
+				MX6QDL_PAD_SD2_DAT1__SD2_DATA1              0x17059
+				MX6QDL_PAD_SD2_DAT2__SD2_DATA2              0x17059
+				MX6QDL_PAD_SD2_DAT3__SD2_DATA3              0x17059
+			>;
+		};
+	};
+};
+
+&ldb {
+	ipu_id = <1>;
+	disp_id = <0>;
+	ext_ref = <1>;
+	mode = "sep0";
+	sec_ipu_id = <1>;
+	sec_disp_id = <1>;
+	status = "okay";
+};
+
+&pcie {
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
+
+&spdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_spdif_sk>;
+	status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-slave";
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_sk>;
+	status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_sk>;
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc1_sk>;
+	cd-gpios = <&gpio2 9 0>;
+	vmmc-supply = <&reg_3p3v>;
+	keep-power-in-suspend;
+	no-1-8-v;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_sk>;
+	cd-gpios = <&gpio2 11 0>;
+	vmmc-supply = <&reg_3p3v>;
+	keep-power-in-suspend;
+	no-1-8-v;
+	status = "okay";
+};
+
+&vpu {
+	pu-supply = <&reg_pu>;
+};
diff -urN fsl/arch/arm/boot/dts/imx6qdl-sodimm.dtsi sk/arch/arm/boot/dts/imx6qdl-sodimm.dtsi
--- fsl/arch/arm/boot/dts/imx6qdl-sodimm.dtsi	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6qdl-sodimm.dtsi	2014-12-08 23:39:25.000000000 +0300
@@ -0,0 +1,700 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/ {
+	aliases {
+		mxcfb0 = &mxcfb1;
+		mxcfb1 = &mxcfb2;
+	};
+
+	backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+	};
+
+	regulators {
+		compatible = "simple-bus";
+
+		reg_3p3v: 3p3v {
+			compatible = "regulator-fixed";
+			regulator-name = "3P3V";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+	};
+
+	mxcfb1: fb@0 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB24";
+		mode_str ="LDB-XGA";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb2: fb@1 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "hdmi";
+		interface_pix_fmt = "RGB24";
+		mode_str = "1280x720M@60";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	lcd@0 {
+		compatible = "fsl,lcd";
+		ipu_id = <0>;
+		disp_id = <0>;
+		default_ifmt = "RGB24";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_disp_sodimm>;
+		status = "okay";
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-tlv320";
+		model = "imx-tlv320";
+		ssi-controller = <&ssi2>;
+		audio-codec = <&codec>;
+		audio-routing =
+			"MICIN", "Mic Jack",
+			"Headphone Jack", "LHPOUT",
+			"Headphone Jack", "RHPOUT";
+		mux-int-port = <2>;
+		mux-ext-port = <5>;
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx6q-audio-hdmi",
+			     "fsl,imx-audio-hdmi";
+		model = "imx-audio-hdmi";
+		hdmi-controller = <&hdmi_audio>;
+	};
+
+	sound-spdif {
+		compatible = "fsl,imx-audio-spdif",
+				"fsl,imx-sabreauto-spdif";
+		model = "imx-spdif";
+		spdif-controller = <&spdif>;
+		spdif-out;
+		spdif-in;
+	};
+
+	v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		ain_num = <1>;
+		status = "okay";
+	};
+	
+	v4l2_out {
+		compatible = "fsl,mxc_v4l2_output";
+		status = "okay";
+	};
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux_sodimm>;
+	status = "okay";
+};
+
+&cpu0 {
+	arm-supply = <&reg_arm>;
+	soc-supply = <&reg_soc>;
+	pu-supply = <&reg_pu>;
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio5 25 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_sodimm>;
+	status = "okay";
+
+	tsc2046@0 {
+		compatible = "ti,tsc2046";
+		reg = <0>;
+		spi-max-frequency = <100000>;
+		/* pen irq is GPIO3_27 */
+		interrupt-parent = <&gpio3>;
+		interrupts = <27 0x2>;
+		pendown-gpio = <&gpio3 27 0>;
+		vcc-supply = <&reg_3p3v>;
+
+		ti,x-min = <150>;
+		ti,x-max = <3830>;
+		ti,y-min = <190>;
+		ti,y-max = <3830>;
+
+		linux,wakeup;
+	};
+};
+
+&ecspi4 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 20 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi4_sodimm>;
+	status = "okay";
+
+	tsc2046@0 {
+		compatible = "ti,tsc2046";
+		reg = <0>;
+		spi-max-frequency = <100000>;
+		/* pen irq is GPIO4_10 */
+		interrupt-parent = <&gpio4>;
+		interrupts = <10 0x2>;
+		pendown-gpio = <&gpio4 10 0>;
+		vcc-supply = <&reg_3p3v>;
+
+		ti,x-min = <150>;
+		ti,x-max = <3830>;
+		ti,y-min = <190>;
+		ti,y-max = <3830>;
+
+		linux,wakeup;
+	};
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet_sodimm>;
+	phy-mode = "rmii";
+	phy-reset-gpios = <&gpio1 23 0>;
+	status = "okay";
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1_sodimm>; /* pin conflict with  LVDS0 TS PENIRQ */
+	status = "disabled";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2_sodimm>;
+	status = "okay";
+};
+
+&gpc {
+	fsl,cpu_pupscr_sw2iso = <0xf>;
+	fsl,cpu_pupscr_sw = <0xf>;
+	fsl,cpu_pdnscr_iso2sw = <0x1>;
+	fsl,cpu_pdnscr_iso = <0x1>;
+	fsl,ldo-bypass = <0>;
+	fsl,wdog-reset = <1>;
+	pu-supply = <&reg_pu>;
+};
+
+&gpu {
+	pu-supply = <&reg_pu>;
+};
+
+&hdmi_audio {
+	status = "okay";
+};
+
+&hdmi_cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_cec_sodimm>;
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <1>;
+	status = "okay";
+};
+
+&hdmi_video {
+	fsl,phy_reg_vlev = <0x0294>;
+	fsl,phy_reg_cksymtx = <0x800d>;
+	status = "okay";
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_sodimm>;
+	status = "okay";
+
+	codec: tlv320aic23@1a {
+		compatible = "ti,tlv320aic23";
+		reg = <0x1a>;
+		clocks = <&clks 200>;
+		clock-frequency = <12000000>;
+	};
+
+	adv7180: adv7180@21 {
+		compatible = "adv,adv7180";
+		reg = <0x21>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_csi_sodimm>;
+		clocks = <&clks 201>;
+		clock-names = "csi_mclk";
+		DOVDD-supply = <&reg_3p3v>;
+		AVDD-supply = <&reg_3p3v>;
+		DVDD-supply = <&reg_3p3v>;
+		PVDD-supply = <&reg_3p3v>;
+		csi_id = <0>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+		cvbs = <1>;
+		cam_std = <0>; /* 0 - PAL(default), 1 - NTSC J , 2 - NTSC M */
+	};
+	
+	hdmi: edid@50 {
+		compatible = "fsl,imx6-hdmi-i2c";
+		reg = <0x50>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	hog {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				/* AUDIO_MCLK */
+				MX6QDL_PAD_NANDF_CS2__CCM_CLKO2             0x80000000
+				/* ECSPI1 CS0 */
+				MX6QDL_PAD_CSI0_DAT7__GPIO5_IO25            0x80000000
+				/* ECSPI4 CS0 */
+				MX6QDL_PAD_EIM_D20__GPIO3_IO20              0x80000000
+				/* LVDS0 TS PENIRQ */
+				MX6QDL_PAD_KEY_COL2__GPIO4_IO10             0x80000000
+				/* LVDS1 TS PENIRQ */
+				MX6QDL_PAD_EIM_D27__GPIO3_IO27              0x80000000
+				/* PHY Reset */
+				MX6QDL_PAD_ENET_REF_CLK__GPIO1_IO23         0x80000000
+				/* SD1 CD */
+				MX6QDL_PAD_SD2_CLK__GPIO1_IO10              0x80000000
+				/* mPCIe reset */
+				MX6QDL_PAD_SD2_DAT3__GPIO1_IO12             0x80000000
+				/* GPIO */
+				MX6QDL_PAD_EIM_A22__GPIO2_IO16              0x80000000
+				MX6QDL_PAD_SD2_CMD__GPIO1_IO11              0x80000000
+				MX6QDL_PAD_SD2_DAT2__GPIO1_IO13             0x80000000
+				MX6QDL_PAD_SD2_DAT1__GPIO1_IO14             0x80000000
+				MX6QDL_PAD_SD2_DAT0__GPIO1_IO15             0x80000000
+			>;
+		};
+	};
+
+	audmux {
+		pinctrl_audmux_sodimm: audmux-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL0__AUD5_TXC               0x130b0
+				MX6QDL_PAD_KEY_ROW0__AUD5_TXD               0x130b0
+				MX6QDL_PAD_KEY_COL1__AUD5_TXFS              0x130b0
+				MX6QDL_PAD_KEY_ROW1__AUD5_RXD               0x130b0
+			>;
+		};
+	};
+
+	ecspi1 {
+		pinctrl_ecspi1_sodimm: ecspi1-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT4__ECSPI1_SCLK           0x100b1
+				MX6QDL_PAD_CSI0_DAT5__ECSPI1_MOSI           0x100b1
+				MX6QDL_PAD_CSI0_DAT6__ECSPI1_MISO           0x100b1
+			>;
+		};
+	};
+
+	ecspi4 {
+		pinctrl_ecspi4_sodimm: ecspi4-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D21__ECSPI4_SCLK             0x100b1
+				MX6QDL_PAD_EIM_D22__ECSPI4_MISO             0x100b1
+				MX6QDL_PAD_EIM_D28__ECSPI4_MOSI             0x100b1
+			>;
+		};
+	};
+
+	fec {
+		pinctrl_enet_sodimm: enet-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK            0x4001b0a8
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO             0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC               0x1b0b0
+				MX6QDL_PAD_ENET_CRS_DV__ENET_RX_EN          0x1b0b0
+				MX6QDL_PAD_ENET_RX_ER__ENET_RX_ER           0x1b0b0
+				MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN           0x1b0b0
+				MX6QDL_PAD_ENET_RXD0__ENET_RX_DATA0         0x1b0b0
+				MX6QDL_PAD_ENET_RXD1__ENET_RX_DATA1         0x1b0b0
+				MX6QDL_PAD_ENET_TXD0__ENET_TX_DATA0         0x1b0b0
+				MX6QDL_PAD_ENET_TXD1__ENET_TX_DATA1         0x1b0b0
+			>;
+		};
+	};
+
+	flexcan1 {
+		pinctrl_flexcan1_sodimm: flexcan1-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL2__FLEXCAN1_TX            0x80000000
+				MX6QDL_PAD_KEY_ROW2__FLEXCAN1_RX            0x80000000
+			>;
+		};
+	};
+
+	flexcan2 {
+		pinctrl_flexcan2_sodimm: flexcan2-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX            0x80000000
+				MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX            0x80000000
+			>;
+		};
+	};
+
+	gpmi-nand {
+		pinctrl_gpmi_nand_sodimm: gpmi-nand-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CLE__NAND_CLE              0xb0b1
+				MX6QDL_PAD_NANDF_ALE__NAND_ALE              0xb0b1
+				MX6QDL_PAD_NANDF_WP_B__NAND_WP_B            0xb0b1
+				MX6QDL_PAD_NANDF_RB0__NAND_READY_B          0xb000
+				MX6QDL_PAD_NANDF_CS0__NAND_CE0_B            0xb0b1
+				MX6QDL_PAD_NANDF_CS1__NAND_CE1_B            0xb0b1
+				MX6QDL_PAD_SD4_CMD__NAND_RE_B               0xb0b1
+				MX6QDL_PAD_SD4_CLK__NAND_WE_B               0xb0b1
+				MX6QDL_PAD_NANDF_D0__NAND_DATA00            0xb0b1
+				MX6QDL_PAD_NANDF_D1__NAND_DATA01            0xb0b1
+				MX6QDL_PAD_NANDF_D2__NAND_DATA02            0xb0b1
+				MX6QDL_PAD_NANDF_D3__NAND_DATA03            0xb0b1
+				MX6QDL_PAD_NANDF_D4__NAND_DATA04            0xb0b1
+				MX6QDL_PAD_NANDF_D5__NAND_DATA05            0xb0b1
+				MX6QDL_PAD_NANDF_D6__NAND_DATA06            0xb0b1
+				MX6QDL_PAD_NANDF_D7__NAND_DATA07            0xb0b1
+				MX6QDL_PAD_SD4_DAT0__NAND_DQS               0x00b1
+			>;
+		};
+	};
+
+	hdmi_cec {
+		pinctrl_hdmi_cec_sodimm: hdmi-cec-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE       0x1f8b0
+			>;
+		};
+	};
+
+	i2c2 {
+		pinctrl_i2c2_sodimm: i2c2-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB2__I2C2_SCL                0x4001b8b1
+				MX6QDL_PAD_EIM_D16__I2C2_SDA                0x4001b8b1
+			>;
+		};
+	};
+
+	i2c3 {
+		pinctrl_i2c3_sodimm: i2c3-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D17__I2C3_SCL                0x4001b8b1
+				MX6QDL_PAD_EIM_D18__I2C3_SDA                0x4001b8b1
+			>;
+		};
+	};
+
+	ipu1 {
+		pinctrl_ipu1_csi_sodimm: ipu1-csi-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__IPU1_CSI0_DATA12     0x80000000
+				MX6QDL_PAD_CSI0_DAT13__IPU1_CSI0_DATA13     0x80000000
+				MX6QDL_PAD_CSI0_DAT14__IPU1_CSI0_DATA14     0x80000000
+				MX6QDL_PAD_CSI0_DAT15__IPU1_CSI0_DATA15     0x80000000
+				MX6QDL_PAD_CSI0_DAT16__IPU1_CSI0_DATA16     0x80000000
+				MX6QDL_PAD_CSI0_DAT17__IPU1_CSI0_DATA17     0x80000000
+				MX6QDL_PAD_CSI0_DAT18__IPU1_CSI0_DATA18     0x80000000
+				MX6QDL_PAD_CSI0_DAT19__IPU1_CSI0_DATA19     0x80000000
+				MX6QDL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK    0x80000000
+				MX6QDL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC       0x80000000
+				MX6QDL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC      0x80000000
+			>;
+		};
+
+		pinctrl_ipu1_disp_sodimm: ipu1-disp-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK  0x10
+				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15        0x10
+				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02         0x10
+				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03         0x10
+				MX6QDL_PAD_DI0_PIN4__IPU1_DI0_PIN04         0x80000000
+				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00    0x10
+				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01    0x10
+				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02    0x10
+				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03    0x10
+				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04    0x10
+				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05    0x10
+				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06    0x10
+				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07    0x10
+				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08    0x10
+				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09    0x10
+				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10   0x10
+				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11   0x10
+				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12   0x10
+				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13   0x10
+				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14   0x10
+				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15   0x10
+				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16   0x10
+				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17   0x10
+				MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18   0x10
+				MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19   0x10
+				MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20   0x10
+				MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21   0x10
+				MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22   0x10
+				MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23   0x10
+			>;
+		};
+	};
+
+	pwm1 {
+		pinctrl_pwm1_sodimm: pwm1-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_9__PWM1_OUT                 0x1b0b1
+			>;
+		};
+	};
+
+	pwm4 {
+		pinctrl_pwm4_sodimm: pwm4-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_DAT2__PWM4_OUT               0x1b0b1
+			>;
+		};
+	};
+
+	spdif {
+		pinctrl_spdif_sodimm: spdif-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_17__SPDIF_OUT               0x1b0b0
+				MX6QDL_PAD_KEY_COL3__SPDIF_IN               0x1b0b0
+			>;
+		};
+	};
+
+	uart1 {
+		pinctrl_uart1_sodimm: uart1-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA        0x1b0b1
+				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA        0x1b0b1
+			>;
+		};
+	};
+
+	uart2 {
+		pinctrl_uart2_sodimm: uart2-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_7__UART2_TX_DATA            0x1b0b1
+				MX6QDL_PAD_GPIO_8__UART2_RX_DATA            0x1b0b1
+			>;
+		};
+	};
+
+	uart3 {
+		pinctrl_uart3_sodimm: uart3-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D24__UART3_TX_DATA           0x1b0b1
+				MX6QDL_PAD_EIM_D25__UART3_RX_DATA           0x1b0b1
+			>;
+		};
+	};
+
+	usbotg {
+		pinctrl_usbotg_sodimm: usbotg-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_1__USB_OTG_ID               0x17059
+			>;
+		};
+	};
+
+	usdhc1 {
+		pinctrl_usdhc1_sodimm: usdhc1-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_CMD__SD1_CMD                 0x17059
+				MX6QDL_PAD_SD1_CLK__SD1_CLK                 0x10059
+				MX6QDL_PAD_SD1_DAT0__SD1_DATA0              0x17059
+				MX6QDL_PAD_SD1_DAT1__SD1_DATA1              0x17059
+				MX6QDL_PAD_SD1_DAT2__SD1_DATA2              0x17059
+				MX6QDL_PAD_SD1_DAT3__SD1_DATA3              0x17059
+			>;
+		};
+	};
+
+	usdhc3 {
+		pinctrl_usdhc3_sodimm: usdhc3-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD                 0x17059
+				MX6QDL_PAD_SD3_CLK__SD3_CLK                 0x10059
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0              0x17059
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1              0x17059
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2              0x17059
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3              0x17059
+				MX6QDL_PAD_SD3_DAT4__SD3_DATA4              0x17059
+				MX6QDL_PAD_SD3_DAT5__SD3_DATA5              0x17059
+				MX6QDL_PAD_SD3_DAT6__SD3_DATA6              0x17059
+				MX6QDL_PAD_SD3_DAT7__SD3_DATA7              0x17059
+			>;
+		};
+	};
+
+	usdhc3 {
+		pinctrl_usdhc3_100mhz_sodimm: usdhc3-100mhz-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD                 0x170B9
+				MX6QDL_PAD_SD3_CLK__SD3_CLK                 0x100B9
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0              0x170B9
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1              0x170B9
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2              0x170B9
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3              0x170B9
+				MX6QDL_PAD_SD3_DAT4__SD3_DATA4              0x170B9
+				MX6QDL_PAD_SD3_DAT5__SD3_DATA5              0x170B9
+				MX6QDL_PAD_SD3_DAT6__SD3_DATA6              0x170B9
+				MX6QDL_PAD_SD3_DAT7__SD3_DATA7              0x170B9
+			>;
+		};
+	};
+
+	weim {
+		pinctrl_weim_sodimm: weim-sodimm {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_BCLK__EIM_BCLK               0x1bb1
+				MX6QDL_PAD_EIM_OE__EIM_OE_B                 0xb0b1
+				MX6QDL_PAD_EIM_RW__EIM_RW                   0xb0b1
+				MX6QDL_PAD_EIM_WAIT__EIM_WAIT_B             0xb060
+				MX6QDL_PAD_EIM_CS0__EIM_CS0_B               0xb0b1
+				MX6QDL_PAD_EIM_CS1__EIM_CS1_B               0xb0b1
+				MX6QDL_PAD_EIM_LBA__EIM_LBA_B               0xb0b1
+				MX6QDL_PAD_EIM_EB0__EIM_EB0_B               0xb0b1
+				MX6QDL_PAD_EIM_EB1__EIM_EB1_B               0xb0b1
+				MX6QDL_PAD_EIM_DA15__EIM_AD15               0xb0b1
+				MX6QDL_PAD_EIM_DA14__EIM_AD14               0xb0b1
+				MX6QDL_PAD_EIM_DA13__EIM_AD13               0xb0b1
+				MX6QDL_PAD_EIM_DA12__EIM_AD12               0xb0b1
+				MX6QDL_PAD_EIM_DA11__EIM_AD11               0xb0b1
+				MX6QDL_PAD_EIM_DA10__EIM_AD10               0xb0b1
+				MX6QDL_PAD_EIM_DA9__EIM_AD09                0xb0b1
+				MX6QDL_PAD_EIM_DA8__EIM_AD08                0xb0b1
+				MX6QDL_PAD_EIM_DA7__EIM_AD07                0xb0b1
+				MX6QDL_PAD_EIM_DA6__EIM_AD06                0xb0b1
+				MX6QDL_PAD_EIM_DA5__EIM_AD05                0xb0b1
+				MX6QDL_PAD_EIM_DA4__EIM_AD04                0xb0b1
+				MX6QDL_PAD_EIM_DA3__EIM_AD03                0xb0b1
+				MX6QDL_PAD_EIM_DA2__EIM_AD02                0xb0b1
+				MX6QDL_PAD_EIM_DA1__EIM_AD01                0xb0b1
+				MX6QDL_PAD_EIM_DA0__EIM_AD00                0xb0b1
+			>;
+		};
+	};
+};
+
+&ldb {
+	ipu_id = <0>;
+	disp_id = <0>;
+	ext_ref = <1>;
+	mode = "sep0";
+	sec_ipu_id = <0>;
+	sec_disp_id = <1>;
+	status = "okay";
+};
+
+&pcie {
+	reset-gpio = <&gpio1 12 0>;
+	status = "okay";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1_sodimm>;
+	status = "okay";
+};
+
+&spdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_spdif_sodimm>;
+	status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-slave";
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_sodimm>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2_sodimm>;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3_sodimm>;
+	status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_sodimm>;
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc1_sodimm>;
+	vmmc-supply = <&reg_3p3v>;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	no-1-8-v;
+	status = "okay";
+};
+
+&usdhc3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc3_100mhz_sodimm>;
+	bus-width = <8>;
+	non-removable;
+	vmmc-supply = <&reg_3p3v>;
+	keep-power-in-suspend;
+	no-1-8-v;
+	status = "okay";
+};
+
+&vpu {
+	pu-supply = <&reg_pu>;
+};
+
+&weim {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_weim_sodimm>;
+	#address-cells = <2>;
+	#size-cells = <1>;
+	ranges = <0 0 0x08000000 0x08000000>;
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6q-hola-aeeb.dts sk/arch/arm/boot/dts/imx6q-hola-aeeb.dts
--- fsl/arch/arm/boot/dts/imx6q-hola-aeeb.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6q-hola-aeeb.dts	2014-11-27 13:03:26.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6q.dtsi"
+#include "imx6qdl-hola.dtsi"
+
+/ {
+	model = "Starterkit i.MX6 Dual Hola-PC Board with Additional Ethernet Extension Board";
+	compatible = "sk,imx6q-hola", "fsl,imx6q-sabresd", "fsl,imx6q";
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&pcie {
+	reset-gpio = <&gpio2 14 0>;
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6q-hola.dts sk/arch/arm/boot/dts/imx6q-hola.dts
--- fsl/arch/arm/boot/dts/imx6q-hola.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6q-hola.dts	2014-10-24 21:56:06.000000000 +0400
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6q.dtsi"
+#include "imx6qdl-hola.dtsi"
+
+/ {
+	model = "Starterkit i.MX6 Dual Hola-PC Board";
+	compatible = "sk,imx6q-hola", "fsl,imx6q-sabresd", "fsl,imx6q";
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6q-hola-feb.dts sk/arch/arm/boot/dts/imx6q-hola-feb.dts
--- fsl/arch/arm/boot/dts/imx6q-hola-feb.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6q-hola-feb.dts	2014-10-26 02:02:02.000000000 +0300
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6q.dtsi"
+#include "imx6qdl-hola.dtsi"
+
+/ {
+	model = "Starterkit i.MX6 Dual Hola-PC Board with FPGA Extension Board";
+	compatible = "sk,imx6q-hola", "fsl,imx6q-sabresd", "fsl,imx6q";
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+};
+
+&ecspi4 { /* spi1 */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi4_hola>;
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 20 0>;
+	status = "okay";
+
+	spi@0 {
+		compatible = "spidev";
+		reg = <0>;
+		spi-max-frequency = <1000000>;
+	};
+};
+
+&ecspi1 { /* spi2 */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_hola>;
+	fsl,spi-num-chipselects = <2>;
+	cs-gpios = <&gpio5 25 0>, <&gpio5 9 0>;
+	status = "okay";
+
+	spi@0 {
+		compatible = "spidev";
+		reg = <0>;
+		spi-max-frequency = <1000000>;
+	};
+
+	spi@1 {
+		compatible = "spidev";
+		reg = <1>;
+		spi-max-frequency = <1000000>;
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6q-hola-ieb.dts sk/arch/arm/boot/dts/imx6q-hola-ieb.dts
--- fsl/arch/arm/boot/dts/imx6q-hola-ieb.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6q-hola-ieb.dts	2014-11-27 13:13:21.000000000 +0300
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6q.dtsi"
+#include "imx6qdl-hola.dtsi"
+
+/ {
+	model = "Starterkit i.MX6 Dual Hola-PC Board with Interfaces Extension Board";
+	compatible = "sk,imx6q-hola", "fsl,imx6q-sabresd", "fsl,imx6q";
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-tlv320";
+		model = "imx-tlv320";
+		ssi-controller = <&ssi2>;
+		audio-codec = <&codec>;
+		audio-routing =
+			"MICIN", "Mic Jack",
+			"Headphone Jack", "LHPOUT",
+			"Headphone Jack", "RHPOUT";
+		mux-int-port = <2>;
+		mux-ext-port = <5>;
+	};
+
+	sound-spdif {
+		compatible = "fsl,imx-audio-spdif",
+				"fsl,imx-sabreauto-spdif";
+		model = "imx-spdif";
+		spdif-controller = <&spdif>;
+		spdif-out;
+	};
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux_hola>;
+	status = "okay";
+};
+
+&ecspi4 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 20 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi4_hola>;
+	status = "okay";
+
+	tsc2046@0 {
+		compatible = "ti,tsc2046";
+		reg = <0>;
+		spi-max-frequency = <100000>;
+		/* pen irq is GPIO3_19 */
+		interrupt-parent = <&gpio3>;
+		interrupts = <19 0x2>;
+		pendown-gpio = <&gpio3 19 0>;
+		vcc-supply = <&reg_3p3v>;
+
+		ti,x-min = <150>;
+		ti,x-max = <3830>;
+		ti,y-min = <190>;
+		ti,y-max = <3830>;
+
+		linux,wakeup;
+	};
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2_hola>;
+	status = "okay";
+};
+
+&i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1_hola>;
+	clock-frequency = <100000>;
+	status = "okay";
+
+	codec: tlv320aic23@1a {
+		compatible = "ti,tlv320aic23";
+		reg = <0x1a>;
+		clocks = <&clks 200>;
+		clock-frequency = <12000000>;
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&pcie {
+	reset-gpio = <&gpio2 14 0>;
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
+
+&spdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_spdif_hola>;
+	status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-slave";
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_hola>;
+	cd-gpios = <&gpio1 8 0>;            /* pin conflict with uart2 */
+	vmmc-supply = <&reg_3p3v>;
+	no-1-8-v;
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6q-hola-vceb.dts sk/arch/arm/boot/dts/imx6q-hola-vceb.dts
--- fsl/arch/arm/boot/dts/imx6q-hola-vceb.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6q-hola-vceb.dts	2014-10-24 21:56:06.000000000 +0400
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6q.dtsi"
+#include "imx6qdl-hola.dtsi"
+
+/ {
+	model = "Starterkit i.MX6 Dual Hola-PC Board with Video Capture Extension Board";
+	compatible = "sk,imx6q-hola", "fsl,imx6q-sabresd", "fsl,imx6q";
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+
+	v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		ain_num = <1>;
+		status = "okay";
+	};
+};
+
+&i2c3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3_hola>;
+	clock-frequency = <100000>;
+	status = "okay";
+
+	adv7180: adv7180@21 {
+		compatible = "adv,adv7180";
+		reg = <0x21>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_csi_hola>;
+		clocks = <&clks 201>;
+		clock-names = "csi_mclk";
+		DOVDD-supply = <&reg_3p3v>;
+		AVDD-supply = <&reg_3p3v>;
+		DVDD-supply = <&reg_3p3v>;
+		PVDD-supply = <&reg_3p3v>;
+		csi_id = <0>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+		cvbs = <1>;
+		cam_std = <0>; /* 0 - PAL(default), 1 - NTSC J , 2 - NTSC M */
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6q-sk.dts sk/arch/arm/boot/dts/imx6q-sk.dts
--- fsl/arch/arm/boot/dts/imx6q-sk.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6q-sk.dts	2014-11-16 19:40:09.000000000 +0300
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6q.dtsi"
+#include "imx6qdl-sk.dtsi"
+
+/ {
+	model = "Starterkit i.MX6 Quad Board";
+	compatible = "sk,imx6q-sk", "fsl,imx6q-sabresd", "fsl,imx6q";
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&mxcfb3 {
+	status = "okay";
+};
+
+&mxcfb4 {
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/imx6q-sodimm.dts sk/arch/arm/boot/dts/imx6q-sodimm.dts
--- fsl/arch/arm/boot/dts/imx6q-sodimm.dts	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/boot/dts/imx6q-sodimm.dts	2014-10-24 21:56:06.000000000 +0400
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2014 starterkit.ru
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License V2.
+ */
+
+/dts-v1/;
+
+#include "imx6q.dtsi"
+#include "imx6qdl-sodimm.dtsi"
+
+/ {
+	model = "Starterkit SK-iMX6D-SODIMM Board";
+	compatible = "sk,imx6q-sodimm", "fsl,imx6q-sabresd", "fsl,imx6q";
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
diff -urN fsl/arch/arm/boot/dts/Makefile sk/arch/arm/boot/dts/Makefile
--- fsl/arch/arm/boot/dts/Makefile	2014-09-18 21:48:51.000000000 +0400
+++ sk/arch/arm/boot/dts/Makefile	2014-10-24 21:59:43.000000000 +0400
@@ -136,6 +136,20 @@
 	imx6sl-evk-csi.dtb \
 	imx6sl-evk-ldo.dtb \
 	imx6sl-evk-pf200.dtb \
+	imx6q-hola.dtb \
+	imx6q-hola-aeeb.dtb \
+	imx6q-hola-feb.dtb \
+	imx6q-hola-ieb.dtb \
+	imx6q-hola-vceb.dtb \
+	imx6dl-hola.dtb \
+	imx6dl-hola-aeeb.dtb \
+	imx6dl-hola-feb.dtb \
+	imx6dl-hola-ieb.dtb \
+	imx6dl-hola-vceb.dtb \
+	imx6dl-oem.dtb \
+	imx6q-sk.dtb \
+	imx6q-sodimm.dtb \
+	imx6dl-sodimm.dtb \
 	vf610-twr.dtb
 dtb-$(CONFIG_ARCH_MXS) += imx23-evk.dtb \
 	imx23-olinuxino.dtb \
diff -urN fsl/arch/arm/configs/imx_v7_sk_defconfig sk/arch/arm/configs/imx_v7_sk_defconfig
--- fsl/arch/arm/configs/imx_v7_sk_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ sk/arch/arm/configs/imx_v7_sk_defconfig	2015-02-18 17:26:18.000000000 +0300
@@ -0,0 +1,3648 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.10.17 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_SPARSE_IRQ=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+CONFIG_RCU_STALL_COMMON=y
+# CONFIG_RCU_USER_QS is not set
+CONFIG_RCU_FANOUT=32
+CONFIG_RCU_FANOUT_LEAF=16
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_RCU_NOCB_CPU is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_RESOURCE_COUNTERS is not set
+# CONFIG_CGROUP_PERF is not set
+# CONFIG_CGROUP_SCHED is not set
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_UIDGID_CONVERTED=y
+# CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_HOTPLUG=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_PCI_QUIRKS=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_MODULE_SIG is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_MULTIPLATFORM=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+
+#
+# Multiple platform selection
+#
+
+#
+# CPU Core family selection
+#
+# CONFIG_ARCH_MULTI_V6 is not set
+CONFIG_ARCH_MULTI_V7=y
+CONFIG_ARCH_MULTI_V6_V7=y
+# CONFIG_ARCH_MULTI_CPU_AUTO is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_ARCH_HIGHBANK is not set
+CONFIG_ARCH_MXC=y
+
+#
+# Freescale i.MX support
+#
+# CONFIG_MXC_IRQ_PRIOR is not set
+# CONFIG_MXC_DEBUG_BOARD is not set
+CONFIG_HAVE_IMX_RNG=y
+CONFIG_HAVE_IMX_ANATOP=y
+CONFIG_HAVE_IMX_GPC=y
+CONFIG_HAVE_IMX_MMDC=y
+CONFIG_HAVE_IMX_SRC=y
+
+#
+# i.MX51 machines:
+#
+# CONFIG_MACH_IMX51_DT is not set
+# CONFIG_MACH_MX51_BABBAGE is not set
+# CONFIG_MACH_EUKREA_CPUIMX51SD is not set
+
+#
+# Device tree only
+#
+# CONFIG_SOC_IMX53 is not set
+CONFIG_SOC_IMX6Q=y
+CONFIG_SOC_IMX6SL=y
+# CONFIG_SOC_VF610 is not set
+# CONFIG_ARCH_OMAP2PLUS is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_WM8850 is not set
+# CONFIG_ARCH_ZYNQ is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_VIRT_EXT=y
+# CONFIG_SWP_EMULATE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_KUSER_HELPERS=y
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_NR_BANKS=8
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+CONFIG_PL310_ERRATA_588369=y
+# CONFIG_ARM_ERRATA_643719 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+CONFIG_PL310_ERRATA_727915=y
+CONFIG_ARM_ERRATA_794072=y
+CONFIG_ARM_ERRATA_761320=y
+# CONFIG_PL310_ERRATA_753970 is not set
+CONFIG_ARM_ERRATA_754322=y
+# CONFIG_ARM_ERRATA_754327 is not set
+CONFIG_ARM_ERRATA_764369=y
+CONFIG_PL310_ERRATA_769419=y
+CONFIG_ARM_ERRATA_775420=y
+# CONFIG_ARM_ERRATA_798181 is not set
+
+#
+# Bus support
+#
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_SYSCALL=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+# CONFIG_PCI_MSI is not set
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_IOV is not set
+# CONFIG_PCI_PRI is not set
+# CONFIG_PCI_PASID is not set
+
+#
+# PCI host controller drivers
+#
+CONFIG_PCIE_DW=y
+CONFIG_PCI_IMX6=y
+# CONFIG_EP_MODE_IN_EP_RC_SYS is not set
+# CONFIG_RC_MODE_IN_EP_RC_SYS is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+# CONFIG_SCHED_MC is not set
+# CONFIG_SCHED_SMT is not set
+CONFIG_HAVE_ARM_SCU=y
+# CONFIG_HAVE_ARM_ARCH_TIMER is not set
+CONFIG_HAVE_ARM_TWD=y
+# CONFIG_MCPM is not set
+# CONFIG_VMSPLIT_3G is not set
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0x80000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_ARM_PSCI is not set
+CONFIG_LOCAL_TIMERS=y
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_XEN is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_ARM_APPENDED_DTB=y
+CONFIG_ARM_ATAG_DTB_COMPAT=y
+CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEND is not set
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+# CONFIG_GENERIC_CPUFREQ_CPU0 is not set
+
+#
+# ARM CPU frequency scaling drivers
+#
+# CONFIG_ARM_BIG_LITTLE_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS4X12_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS5250_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS5440_CPUFREQ is not set
+CONFIG_ARM_IMX6_CPUFREQ=y
+# CONFIG_ARM_KIRKWOOD_CPUFREQ is not set
+CONFIG_CPU_IDLE=y
+# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_ADVANCED_DEBUG is not set
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_PM_SLEEP_DEBUG=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_HAS_OPP=y
+CONFIG_PM_OPP=y
+CONFIG_PM_CLK=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=y
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_GRE is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_ADVANCED is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+# CONFIG_NF_CONNTRACK is not set
+CONFIG_NETFILTER_XTABLES=m
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=m
+
+#
+# Xtables targets
+#
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+
+#
+# Xtables matches
+#
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_IP_NF_MANGLE=m
+# CONFIG_IP_NF_RAW is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV6 is not set
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+# CONFIG_IP6_NF_RAW is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_MMAP is not set
+# CONFIG_NETLINK_DIAG is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_GW=y
+
+#
+# CAN Device Drivers
+#
+# CONFIG_CAN_VCAN is not set
+# CONFIG_CAN_SLCAN is not set
+CONFIG_CAN_DEV=y
+CONFIG_CAN_CALC_BITTIMING=y
+# CONFIG_CAN_LEDS is not set
+# CONFIG_CAN_AT91 is not set
+# CONFIG_CAN_MCP251X is not set
+CONFIG_HAVE_CAN_FLEXCAN=y
+CONFIG_CAN_FLEXCAN=y
+# CONFIG_PCH_CAN is not set
+# CONFIG_CAN_GRCAN is not set
+# CONFIG_CAN_SJA1000 is not set
+# CONFIG_CAN_C_CAN is not set
+# CONFIG_CAN_CC770 is not set
+
+#
+# CAN USB interfaces
+#
+# CONFIG_CAN_EMS_USB is not set
+# CONFIG_CAN_ESD_USB2 is not set
+# CONFIG_CAN_KVASER_USB is not set
+# CONFIG_CAN_PEAK_USB is not set
+# CONFIG_CAN_8DEV_USB is not set
+# CONFIG_CAN_SOFTING is not set
+# CONFIG_CAN_DEBUG_DEVICES is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+CONFIG_MAC80211_HAS_RC=y
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_LEDS is not set
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_MESSAGE_TRACING is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_SOC_BUS=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=320
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_CMA_AREAS=7
+
+#
+# Bus devices
+#
+CONFIG_IMX_WEIM=y
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_PHYSMAP_OF=y
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+CONFIG_MTD_DATAFLASH=y
+# CONFIG_MTD_DATAFLASH_WRITE_VERIFY is not set
+# CONFIG_MTD_DATAFLASH_OTP is not set
+CONFIG_MTD_M25P80=y
+CONFIG_M25PXX_USE_FAST_READ=y
+CONFIG_MTD_SST25L=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_DENALI is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_RICOH is not set
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_DOCG4 is not set
+# CONFIG_MTD_NAND_CAFE is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_GPMI_NAND=y
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_NAND_MXC is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=256
+CONFIG_MTD_UBI_BEB_LIMIT=20
+# CONFIG_MTD_UBI_FASTMAP is not set
+# CONFIG_MTD_UBI_GLUEBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+
+#
+# Device Tree and Open Firmware support
+#
+# CONFIG_PROC_DEVICETREE is not set
+# CONFIG_OF_SELFTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_DEVICE=y
+CONFIG_OF_I2C=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_PCI=y
+CONFIG_OF_PCI_IRQ=y
+CONFIG_OF_MTD=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_BMP085_SPI is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+CONFIG_SRAM=y
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+# CONFIG_SATA_AHCI is not set
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_IMX=y
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SX4 is not set
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+# CONFIG_ATA_PIIX is not set
+# CONFIG_SATA_HIGHBANK is not set
+# CONFIG_SATA_MV is not set
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARASAN_CF is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IMX is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SCH is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_RZ1000 is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_LEGACY is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+CONFIG_MII=y
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+CONFIG_ETHERNET=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_FEC=y
+# CONFIG_NET_VENDOR_HP is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_IP1000 is not set
+# CONFIG_JME is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+CONFIG_NET_VENDOR_REALTEK=y
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+CONFIG_R8169=y
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_PPP=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=m
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+# CONFIG_SLIP is not set
+CONFIG_SLHC=m
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+CONFIG_USB_USBNET=y
+# CONFIG_USB_NET_AX8817X is not set
+# CONFIG_USB_NET_AX88179_178A is not set
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_CDC_EEM is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_CDC_MBIM is not set
+# CONFIG_USB_NET_DM9601 is not set
+CONFIG_USB_NET_SMSC75XX=y
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+# CONFIG_USB_NET_QMI_WWAN is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_SIERRA_NET is not set
+CONFIG_WLAN=y
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_ATMEL is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_RTL8180 is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_ADM8211 is not set
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_MWL8K is not set
+# CONFIG_ATH_CARDS is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_BRCMFMAC is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW2200 is not set
+# CONFIG_IWLWIFI is not set
+# CONFIG_IWL4965 is not set
+# CONFIG_IWL3945 is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_HERMES is not set
+# CONFIG_P54_COMMON is not set
+CONFIG_RT2X00=m
+# CONFIG_RT2400PCI is not set
+# CONFIG_RT2500PCI is not set
+# CONFIG_RT61PCI is not set
+# CONFIG_RT2800PCI is not set
+# CONFIG_RT2500USB is not set
+# CONFIG_RT73USB is not set
+CONFIG_RT2800USB=m
+CONFIG_RT2800USB_RT33XX=y
+CONFIG_RT2800USB_RT35XX=y
+CONFIG_RT2800USB_RT53XX=y
+CONFIG_RT2800USB_RT55XX=y
+CONFIG_RT2800USB_UNKNOWN=y
+CONFIG_RT2800_LIB=m
+CONFIG_RT2X00_LIB_USB=m
+CONFIG_RT2X00_LIB=m
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_RT2X00_LIB_CRYPTO=y
+CONFIG_RT2X00_LIB_LEDS=y
+# CONFIG_RT2X00_DEBUG is not set
+CONFIG_RTLWIFI=m
+# CONFIG_RTLWIFI_DEBUG is not set
+# CONFIG_RTL8192CE is not set
+# CONFIG_RTL8192SE is not set
+# CONFIG_RTL8192DE is not set
+# CONFIG_RTL8723AE is not set
+# CONFIG_RTL8188EE is not set
+CONFIG_RTL8192CU=m
+CONFIG_RTL8192C_COMMON=m
+# CONFIG_WL_TI is not set
+# CONFIG_ZD1211RW is not set
+# CONFIG_MWIFIEX is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+CONFIG_INPUT_MATRIXKMAP=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_IMX is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=y
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_ELAN is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+CONFIG_TOUCHSCREEN_MAX11801=y
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_ISL29023 is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_MFD_HSU is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+# CONFIG_TTY_PRINTK is not set
+CONFIG_FSL_OTP=y
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_ATMEL is not set
+# CONFIG_HW_RANDOM_IMX_RNG is not set
+# CONFIG_HW_RANDOM_EXYNOS is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+CONFIG_MXS_VIIM=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_SMBUS is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_ALGOPCF=m
+CONFIG_I2C_ALGOPCA=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EG20T is not set
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_IMX=y
+# CONFIG_I2C_INTEL_MID is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_GPIO=y
+CONFIG_SPI_IMX=y
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_TOPCLIFF_PCH is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# Qualcomm MSM SSBI bus support
+#
+# CONFIG_SSBI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=y
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+CONFIG_PINMUX=y
+CONFIG_PINCONF=y
+# CONFIG_DEBUG_PINCTRL is not set
+CONFIG_PINCTRL_IMX=y
+CONFIG_PINCTRL_IMX6Q=y
+CONFIG_PINCTRL_IMX6SL=y
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_EXYNOS is not set
+# CONFIG_PINCTRL_EXYNOS5440 is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+CONFIG_GPIOLIB=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_EM is not set
+CONFIG_GPIO_MXC=y
+# CONFIG_GPIO_RCAR is not set
+# CONFIG_GPIO_TS5500 is not set
+# CONFIG_GPIO_VX855 is not set
+# CONFIG_GPIO_GRGPIO is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+
+#
+# PCI GPIO expanders:
+#
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_AMD8111 is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_RDC321X is not set
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+
+#
+# USB GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_SABRESD_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+CONFIG_IMX6_USB_CHARGER=y
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7310 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX17135 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_MAG3110 is not set
+# CONFIG_MXC_MMA8451 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+CONFIG_CPU_THERMAL=y
+# CONFIG_THERMAL_EMULATION is not set
+CONFIG_IMX_THERMAL=y
+CONFIG_DEVICE_THERMAL=y
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_CORE is not set
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MPCORE_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+CONFIG_IMX2_WDT=y
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+CONFIG_MFD_MXC_HDMI=y
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX17135 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TIMBERDALE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+CONFIG_REGULATOR_ANATOP=y
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+CONFIG_REGULATOR_PFUZE100=y
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_RC_SUPPORT is not set
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_CONTIG=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+CONFIG_VIDEOBUF2_VMALLOC=y
+CONFIG_VIDEO_V4L2_INT_DEVICE=y
+# CONFIG_TTPCI_EEPROM is not set
+
+#
+# Media drivers
+#
+CONFIG_MEDIA_USB_SUPPORT=y
+
+#
+# Webcam devices
+#
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+# CONFIG_USB_GSPCA is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_USB_SN9C102 is not set
+
+#
+# Webcam, TV (analog/digital) USB devices
+#
+# CONFIG_VIDEO_EM28XX is not set
+CONFIG_MEDIA_PCI_SUPPORT=y
+
+#
+# Media capture support
+#
+CONFIG_VIDEO_TW6869=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+# CONFIG_VIDEO_CAFE_CCIC is not set
+# CONFIG_VIDEO_TIMBERDALE is not set
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_CAPTURE=y
+
+#
+# MXC Camera/V4L2 PRP Features support
+#
+CONFIG_VIDEO_MXC_IPU_CAMERA=y
+# CONFIG_VIDEO_MXC_CSI_CAMERA is not set
+# CONFIG_MXC_CAMERA_OV5640 is not set
+# CONFIG_MXC_CAMERA_OV5642 is not set
+# CONFIG_MXC_CAMERA_OV5640_MIPI is not set
+CONFIG_MXC_TVIN_ADV7180=y
+CONFIG_MXC_IPU_DEVICE_QUEUE_SDC=y
+# CONFIG_MXC_IPU_PRP_VF_SDC is not set
+CONFIG_MXC_IPU_PRP_ENC=y
+CONFIG_MXC_IPU_CSI_ENC=y
+CONFIG_VIDEO_MXC_IPU_OUTPUT=y
+CONFIG_VIDEO_MXC_PXP_V4L2=y
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+# CONFIG_CYPRESS_FIRMWARE is not set
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, frontends)
+#
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+
+#
+# Encoders, decoders, sensors and other helper chips
+#
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_UDA1342 is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+# CONFIG_VIDEO_SONY_BTF_MPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_ADV7183 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_TW2804 is not set
+# CONFIG_VIDEO_TW9903 is not set
+# CONFIG_VIDEO_TW9906 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_ADV7393 is not set
+# CONFIG_VIDEO_AK881X is not set
+
+#
+# Camera sensor devices
+#
+# CONFIG_VIDEO_OV7640 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_VS6624 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_TCM825X is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+
+#
+# Miscelaneous helper chips
+#
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_M52790 is not set
+
+#
+# Sensors used on soc_camera driver
+#
+
+#
+# Customise DVB Frontends
+#
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+
+#
+# Graphics support
+#
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_DRM=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+CONFIG_DRM_VIVANTE=y
+# CONFIG_DRM_EXYNOS is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_TILCDC is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_TEGRA_HOST1X is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_VIDEOMODE_HELPERS=y
+CONFIG_HDMI=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+CONFIG_FB_MX3=y
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+CONFIG_FB_MXS=y
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_EXYNOS_VIDEO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI922X is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+CONFIG_LCD_PLATFORM=y
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+# CONFIG_LCD_LMS501KF03 is not set
+# CONFIG_LCD_HX8357 is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_PWM=y
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+CONFIG_FB_MXC=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+CONFIG_FB_MXC_LDB=y
+# CONFIG_FB_MXC_MIPI_DSI is not set
+CONFIG_FB_MXC_HDMI=y
+CONFIG_FB_MXC_EDID=y
+# CONFIG_FB_MXC_EINK_PANEL is not set
+# CONFIG_FB_MXS_SII902X is not set
+# CONFIG_HANNSTAR_CABC is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_FB_SSD1307 is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_RAWMIDI=y
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_HDA_INTEL is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=y
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_DMAENGINE_PCM=y
+CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM=y
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+CONFIG_SND_SOC_FSL_SSI=y
+CONFIG_SND_SOC_FSL_ASRC=y
+CONFIG_SND_SOC_FSL_SPDIF=y
+CONFIG_SND_SOC_FSL_HDMI=y
+CONFIG_SND_SOC_FSL_UTILS=y
+CONFIG_SND_IMX_SOC=y
+CONFIG_SND_SOC_IMX_PCM_DMA=y
+CONFIG_SND_SOC_IMX_HDMI_DMA=y
+CONFIG_SND_SOC_IMX_AUDMUX=y
+# CONFIG_SND_SOC_IMX_CS42888 is not set
+# CONFIG_SND_SOC_IMX_WM8962 is not set
+# CONFIG_SND_SOC_IMX_SGTL5000 is not set
+CONFIG_SND_SOC_IMX_TLV320=y
+CONFIG_SND_SOC_IMX_SPDIF=y
+CONFIG_SND_SOC_IMX_HDMI=y
+# CONFIG_SND_SOC_IMX_SI476X is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_OMAP_HDMI_CODEC=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_SND_SOC_TLV320AIC23=y
+# CONFIG_SND_SIMPLE_CARD is not set
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO_TPKBD is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_PS3REMOTE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WIIMOTE is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=y
+# CONFIG_USB_EHCI_MXC is not set
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_IMX21_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_DWC3 is not set
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+# CONFIG_USB_CHIPIDEA_DEBUG is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_F81232 is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_METRO is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+CONFIG_USB_SERIAL_PL2303=m
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_WWAN=m
+CONFIG_USB_SERIAL_OPTION=m
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_XSENS_MT is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_WISHBONE is not set
+# CONFIG_USB_SERIAL_ZTE is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_QT2 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+CONFIG_USB_PHY=y
+CONFIG_NOP_USB_XCEIV=y
+# CONFIG_OMAP_CONTROL_USB is not set
+# CONFIG_OMAP_USB3 is not set
+# CONFIG_SAMSUNG_USBPHY is not set
+# CONFIG_SAMSUNG_USB2PHY is not set
+# CONFIG_SAMSUNG_USB3PHY is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+CONFIG_USB_MXS_PHY=y
+# CONFIG_USB_RCAR_PHY is not set
+# CONFIG_USB_ULPI is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FSL_USB2 is not set
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_AMD5536UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_EG20T is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_LIBCOMPOSITE=m
+CONFIG_USB_F_ACM=m
+CONFIG_USB_F_SS_LB=m
+CONFIG_USB_U_SERIAL=m
+CONFIG_USB_F_SERIAL=m
+CONFIG_USB_F_OBEX=m
+CONFIG_USB_ZERO=m
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_ETH_EEM is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_MASS_STORAGE=m
+# CONFIG_FSL_UTP is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+# CONFIG_UWB is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_IO_ACCESSORS=y
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_MXC is not set
+# CONFIG_MMC_TIFM_SD is not set
+# CONFIG_MMC_CB710 is not set
+# CONFIG_MMC_VIA_SDMMC is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+
+#
+# MXC support drivers
+#
+CONFIG_MXC_IPU=y
+
+#
+# MXC Vivante GPU support
+#
+CONFIG_MXC_GPU_VIV=y
+CONFIG_MXC_IPU_V3=y
+
+#
+# MXC Asynchronous Sample Rate Converter support
+#
+CONFIG_MXC_ASRC=y
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+CONFIG_MXC_VPU=y
+# CONFIG_MXC_VPU_DEBUG is not set
+# CONFIG_MX6_VPU_352M is not set
+
+#
+# MXC HDMI CEC (Consumer Electronics Control) support
+#
+# CONFIG_MXC_HDMI_CEC is not set
+
+#
+# MXC MIPI Support
+#
+CONFIG_MXC_MIPI_CSI2=y
+
+#
+# MXC Media Local Bus Driver
+#
+CONFIG_MXC_MLB=y
+CONFIG_MXC_MLB150=m
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA9633 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_RENESAS_TPU is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_OT200 is not set
+# CONFIG_LEDS_BLINKM is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+# CONFIG_LEDS_TRIGGER_ONESHOT is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_CPU is not set
+CONFIG_LEDS_TRIGGER_GPIO=y
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
+# CONFIG_LEDS_TRIGGER_CAMERA is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_IMXDI is not set
+CONFIG_RTC_DRV_MXC=y
+CONFIG_RTC_DRV_SNVS=y
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+# CONFIG_DW_DMAC is not set
+CONFIG_MX3_IPU=y
+CONFIG_MX3_IPU_IRQS=4
+CONFIG_MXC_PXP_V2=y
+CONFIG_MXC_PXP_CLIENT_DEVICE=y
+# CONFIG_TIMB_DMA is not set
+CONFIG_IMX_SDMA=y
+# CONFIG_IMX_DMA is not set
+CONFIG_MXS_DMA=y
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_OF=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+CONFIG_STAGING=y
+# CONFIG_ET131X is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_W35UND is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_R8187SE is not set
+# CONFIG_RTL8192U is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_R8712U is not set
+# CONFIG_RTS5139 is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_IDE_PHISON is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_VT6655 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_DX_SEP is not set
+# CONFIG_ZSMALLOC is not set
+# CONFIG_FB_SM7XX is not set
+# CONFIG_CRYSTALHD is not set
+# CONFIG_FB_XGI is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_USB_WPAN_HCD is not set
+# CONFIG_WIMAX_GDM72XX is not set
+# CONFIG_CSR_WIFI is not set
+CONFIG_NET_VENDOR_SILICOM=y
+# CONFIG_SBYPASS is not set
+# CONFIG_BPCTL is not set
+# CONFIG_CED1401 is not set
+# CONFIG_DRM_IMX is not set
+# CONFIG_DGRP is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+CONFIG_COMMON_CLK_DEBUG=y
+# CONFIG_COMMON_CLK_SI5351 is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_MMIO=y
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_VME_BUS is not set
+CONFIG_PWM=y
+CONFIG_PWM_IMX=y
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+# CONFIG_IPACK_BUS is not set
+CONFIG_ARCH_HAS_RESET_CONTROLLER=y
+CONFIG_RESET_CONTROLLER=y
+CONFIG_RESET_GPIO=y
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=m
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU_DELAY is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_IMX_UART_PORT=1
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
+# CONFIG_PID_IN_CONTEXTIDR is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+CONFIG_SECURITYFS=y
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_TEST=m
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_LRW=y
+# CONFIG_CRYPTO_PCBC is not set
+CONFIG_CRYPTO_XTS=y
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+CONFIG_CRYPTO_GHASH=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_RMD128=y
+CONFIG_CRYPTO_RMD160=y
+CONFIG_CRYPTO_RMD256=y
+CONFIG_CRYPTO_RMD320=y
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA1_ARM is not set
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_WP512=y
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_ARM is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_BLOWFISH_COMMON=y
+CONFIG_CRYPTO_CAMELLIA=y
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_RINGSIZE=9
+# CONFIG_CRYPTO_DEV_FSL_CAAM_INTC is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_AHASH_API=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_API=y
+# CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_TEST is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_SLOTSIZE=7
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_STMP_DEVICE=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=y
+# CONFIG_VIRTUALIZATION is not set
diff -urN fsl/arch/arm/mach-imx/busfreq-imx6.c sk/arch/arm/mach-imx/busfreq-imx6.c
--- fsl/arch/arm/mach-imx/busfreq-imx6.c	2014-09-18 21:48:51.000000000 +0400
+++ sk/arch/arm/mach-imx/busfreq-imx6.c	2014-12-22 01:38:47.000000000 +0300
@@ -66,6 +66,7 @@
 static int bus_freq_scaling_is_active;
 static int high_bus_count, med_bus_count, audio_bus_count, low_bus_count;
 static unsigned int ddr_low_rate;
+static int sk_imx6q_ddr_400;
 
 extern int init_mmdc_lpddr2_settings(struct platform_device *dev);
 extern int init_mmdc_ddr3_settings(struct platform_device *dev);
@@ -611,6 +612,11 @@
 				 struct device_attribute *attr,
 				 const char *buf, size_t size)
 {
+	if (sk_imx6q_ddr_400) {
+		printk("SK: i.MX6Q DDR 400M, bus frequency scaling is disabled\n");
+		return size;
+	}
+
 	if (strncmp(buf, "1", 1) == 0) {
 		bus_freq_scaling_is_active = 1;
 		set_high_bus_freq(1);
@@ -888,6 +894,16 @@
 		dev_err(busfreq_dev, "Busfreq init of MMDC failed\n");
 		return err;
 	}
+
+	sk_imx6q_ddr_400 = 0;
+	if (cpu_is_imx6q() && (clk_get_rate(periph_pre_clk) == 396000000)) {
+		clk_set_parent(periph_pre_clk, pll2_400);
+		clk_set_parent(periph_clk, periph_pre_clk);
+
+		sk_imx6q_ddr_400 = 1;
+		printk("SK: i.MX6Q DDR 400M, disable bus frequency scaling\n");
+		bus_freq_scaling_is_active = 0;
+	}
 	return 0;
 }
 
diff -urN fsl/arch/arm/mach-imx/clk-imx6q.c sk/arch/arm/mach-imx/clk-imx6q.c
--- fsl/arch/arm/mach-imx/clk-imx6q.c	2014-09-18 21:48:51.000000000 +0400
+++ sk/arch/arm/mach-imx/clk-imx6q.c	2014-12-22 01:38:47.000000000 +0300
@@ -587,10 +587,7 @@
 	/* Make sure PFDs are disabled at boot. */
 	reg = readl_relaxed(anatop_base + 0x100);
 	/* Cannot disable pll2_pfd2_396M, as it is the MMDC clock in iMX6DL */
-	if (cpu_is_imx6dl())
-		reg |= 0x80008080;
-	else
-		reg |= 0x80808080;
+	reg |= 0x80008080;
 	writel_relaxed(reg, anatop_base + 0x100);
 
 	/* Disable PLL3 PFDs. */
diff -urN fsl/drivers/input/touchscreen/ads7846.c sk/drivers/input/touchscreen/ads7846.c
--- fsl/drivers/input/touchscreen/ads7846.c	2014-09-18 21:48:51.000000000 +0400
+++ sk/drivers/input/touchscreen/ads7846.c	2014-10-24 21:56:06.000000000 +0400
@@ -27,6 +27,9 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/pm.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
 #include <linux/gpio.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/ads7846.h>
@@ -104,12 +107,8 @@
 #endif
 
 	u16			model;
-	u16			vref_mv;
 	u16			vref_delay_usecs;
-	u16			x_plate_ohms;
-	u16			pressure_max;
 
-	bool			swap_xy;
 	bool			use_internal;
 
 	struct ads7846_packet	*packet;
@@ -143,6 +142,9 @@
 	int			gpio_pendown;
 
 	void			(*wait_for_sync)(void);
+
+	/* platform data from board file or DT */
+	struct ads7846_platform_data *pdata;
 };
 
 /* leave chip selected when we're done, for quicker re-select? */
@@ -456,7 +458,7 @@
 	unsigned retval = v;
 
 	/* external resistors may scale vAUX into 0..vREF */
-	retval *= ts->vref_mv;
+	retval *= ts->pdata->vref_mv;
 	retval = retval >> 12;
 
 	return retval;
@@ -515,25 +517,25 @@
 	/* hwmon sensors need a reference voltage */
 	switch (ts->model) {
 	case 7846:
-		if (!ts->vref_mv) {
+		if (!ts->pdata->vref_mv) {
 			dev_dbg(&spi->dev, "assuming 2.5V internal vREF\n");
-			ts->vref_mv = 2500;
+			ts->pdata->vref_mv = 2500;
 			ts->use_internal = true;
 		}
 		break;
 	case 7845:
 	case 7843:
-		if (!ts->vref_mv) {
+		if (!ts->pdata->vref_mv) {
 			dev_warn(&spi->dev,
 				"external vREF for ADS%d not specified\n",
-				ts->model);
+				ts->pdata->model);
 			return 0;
 		}
 		break;
 	}
 
 	/* different chips have different sensor groups */
-	switch (ts->model) {
+	switch (ts->pdata->model) {
 	case 7846:
 		ts->attr_group = &ads7846_attr_group;
 		break;
@@ -544,7 +546,7 @@
 		ts->attr_group = &ads7843_attr_group;
 		break;
 	default:
-		dev_dbg(&spi->dev, "ADS%d not recognized\n", ts->model);
+		dev_dbg(&spi->dev, "ADS%d not recognized\n", ts->pdata->model);
 		return 0;
 	}
 
@@ -700,7 +702,7 @@
 	struct spi_transfer *t =
 		list_entry(m->transfers.prev, struct spi_transfer, transfer_list);
 
-	if (ts->model == 7845) {
+	if (ts->pdata->model == 7845) {
 		return be16_to_cpup((__be16 *)&(((char*)t->rx_buf)[1])) >> 3;
 	} else {
 		/*
@@ -776,6 +778,7 @@
 static void ads7846_report_state(struct ads7846 *ts)
 {
 	struct ads7846_packet *packet = ts->packet;
+	struct ads7846_platform_data *pdata = ts->pdata;
 	unsigned int Rt;
 	u16 x, y, z1, z2;
 
@@ -784,7 +787,7 @@
 	 * from on-the-wire format as part of debouncing to get stable
 	 * readings.
 	 */
-	if (ts->model == 7845) {
+	if (pdata->model == 7845) {
 		x = *(u16 *)packet->tc.x_buf;
 		y = *(u16 *)packet->tc.y_buf;
 		z1 = 0;
@@ -800,11 +803,11 @@
 	if (x == MAX_12BIT)
 		x = 0;
 
-	if (ts->model == 7843) {
-		Rt = ts->pressure_max / 2;
-	} else if (ts->model == 7845) {
+	if (pdata->model == 7843) {
+		Rt = pdata->pressure_max / 2;
+	} else if (pdata->model == 7845) {
 		if (get_pendown_state(ts))
-			Rt = ts->pressure_max / 2;
+			Rt = pdata->pressure_max / 2;
 		else
 			Rt = 0;
 		dev_vdbg(&ts->spi->dev, "x/y: %d/%d, PD %d\n", x, y, Rt);
@@ -813,7 +816,7 @@
 		Rt = z2;
 		Rt -= z1;
 		Rt *= x;
-		Rt *= ts->x_plate_ohms;
+		Rt *= pdata->x_plate_ohms;
 		Rt /= z1;
 		Rt = (Rt + 2047) >> 12;
 	} else {
@@ -825,7 +828,7 @@
 	 * the maximum. Don't report it to user space, repeat at least
 	 * once more the measurement
 	 */
-	if (packet->tc.ignore || Rt > ts->pressure_max) {
+	if (packet->tc.ignore || Rt > pdata->pressure_max) {
 		dev_vdbg(&ts->spi->dev, "ignored %d pressure %d\n",
 			 packet->tc.ignore, Rt);
 		return;
@@ -853,7 +856,7 @@
 	if (Rt) {
 		struct input_dev *input = ts->input;
 
-		if (ts->swap_xy)
+		if (pdata->swap_xy)
 			swap(x, y);
 
 		if (!ts->pendown) {
@@ -864,7 +867,7 @@
 
 		input_report_abs(input, ABS_X, x);
 		input_report_abs(input, ABS_Y, y);
-		input_report_abs(input, ABS_PRESSURE, ts->pressure_max - Rt);
+		input_report_abs(input, ABS_PRESSURE, pdata->pressure_max - Rt);
 
 		input_sync(input);
 		dev_vdbg(&ts->spi->dev, "%4d/%4d/%4d\n", x, y, Rt);
@@ -963,7 +966,7 @@
 static int ads7846_setup_pendown(struct spi_device *spi,
 					   struct ads7846 *ts)
 {
-	struct ads7846_platform_data *pdata = spi->dev.platform_data;
+	struct ads7846_platform_data *pdata = ts->pdata;
 	int err;
 
 	/*
@@ -1003,20 +1006,20 @@
  * use formula #2 for pressure, not #3.
  */
 static void ads7846_setup_spi_msg(struct ads7846 *ts,
-				const struct ads7846_platform_data *pdata)
+				  struct ads7846_platform_data *pdata)
 {
 	struct spi_message *m = &ts->msg[0];
 	struct spi_transfer *x = ts->xfer;
 	struct ads7846_packet *packet = ts->packet;
 	int vref = pdata->keep_vref_on;
 
-	if (ts->model == 7873) {
+	if (pdata->model == 7873) {
 		/*
 		 * The AD7873 is almost identical to the ADS7846
 		 * keep VREF off during differential/ratiometric
 		 * conversion modes.
 		 */
-		ts->model = 7846;
+		pdata->model = 7846;
 		vref = 0;
 	}
 
@@ -1024,7 +1027,7 @@
 	spi_message_init(m);
 	m->context = ts;
 
-	if (ts->model == 7845) {
+	if (pdata->model == 7845) {
 		packet->read_y_cmd[0] = READ_Y(vref);
 		packet->read_y_cmd[1] = 0;
 		packet->read_y_cmd[2] = 0;
@@ -1069,7 +1072,7 @@
 	spi_message_init(m);
 	m->context = ts;
 
-	if (ts->model == 7845) {
+	if (pdata->model == 7845) {
 		x++;
 		packet->read_x_cmd[0] = READ_X(vref);
 		packet->read_x_cmd[1] = 0;
@@ -1108,7 +1111,7 @@
 	}
 
 	/* turn y+ off, x- on; we'll use formula #2 */
-	if (ts->model == 7846) {
+	if (pdata->model == 7846) {
 		ts->msg_count++;
 		m++;
 		spi_message_init(m);
@@ -1178,7 +1181,7 @@
 	spi_message_init(m);
 	m->context = ts;
 
-	if (ts->model == 7845) {
+	if (pdata->model == 7845) {
 		x++;
 		packet->pwrdown_cmd[0] = PWRDOWN;
 		packet->pwrdown_cmd[1] = 0;
@@ -1201,12 +1204,110 @@
 	spi_message_add_tail(x, m);
 }
 
+#ifdef CONFIG_OF
+static const struct of_device_id ads7846_dt_ids[] = {
+	{ .compatible = "ti,tsc2046",	.data = (void *) 7846 },
+	{ .compatible = "ti,ads7843",	.data = (void *) 7843 },
+	{ .compatible = "ti,ads7845",	.data = (void *) 7845 },
+	{ .compatible = "ti,ads7846",	.data = (void *) 7846 },
+	{ .compatible = "ti,ads7873",	.data = (void *) 7873 },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ads7846_dt_ids);
+
+static struct ads7846_platform_data *ads7846_probe_dt(struct device *dev)
+{
+	struct ads7846_platform_data *pdata = NULL;
+	const struct of_device_id *match;
+	u32 val;
+
+	match = of_match_device(ads7846_dt_ids, dev);
+	if (!match)
+		return NULL;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return NULL;
+
+	pdata->model = (unsigned int) match->data;
+
+	if (of_property_read_u32(dev->of_node, "ti,vref-delay-usecs", &val) == 0)
+		pdata->vref_delay_usecs = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,vref-mv", &val) == 0)
+		pdata->vref_mv = val;
+
+	if (of_get_property(dev->of_node, "ti,keep-vref-on", NULL))
+		pdata->keep_vref_on = true;
+
+	if (of_get_property(dev->of_node, "ti,swap-xy", NULL))
+		pdata->swap_xy = true;
+
+	if (of_property_read_u32(dev->of_node, "ti,settle-delay-usec",
+				 &val) == 0)
+		pdata->settle_delay_usecs = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,penirq-recheck-delay-usecs",
+				 &val) == 0)
+		pdata->penirq_recheck_delay_usecs = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,x-plate-ohms", &val) == 0)
+		pdata->x_plate_ohms = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,y-plate-ohms", &val) == 0)
+		pdata->y_plate_ohms = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,x-min", &val) == 0)
+		pdata->x_min = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,y-min", &val) == 0)
+		pdata->y_min = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,x-max", &val) == 0)
+		pdata->x_max = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,y-max", &val) == 0)
+		pdata->y_max = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,pressure-min", &val) == 0)
+		pdata->pressure_min = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,pressure-max", &val) == 0)
+		pdata->pressure_max = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,debounce-max", &val) == 0)
+		pdata->debounce_max = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,debounce-tol", &val) == 0)
+		pdata->debounce_tol = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,debounce-rep", &val) == 0)
+		pdata->debounce_rep = val;
+
+	if (of_property_read_u32(dev->of_node, "ti,pendown-gpio-debounce",
+				 &val) == 0)
+		pdata->gpio_pendown_debounce = val;
+
+	pdata->gpio_pendown = of_get_named_gpio(dev->of_node, "pendown-gpio", 0);
+
+	if (of_get_property(dev->of_node, "linux,wakeup", NULL))
+		pdata->wakeup = true;
+
+	return pdata;
+}
+#else
+static inline struct ads7846_platform_data ads7846_probe_dt(struct device *dev)
+{
+	return NULL;
+}
+#endif
+
 static int ads7846_probe(struct spi_device *spi)
 {
 	struct ads7846 *ts;
 	struct ads7846_packet *packet;
 	struct input_dev *input_dev;
-	struct ads7846_platform_data *pdata = spi->dev.platform_data;
+	struct ads7846_platform_data *pdata = NULL;
 	unsigned long irq_flags;
 	int err;
 
@@ -1215,6 +1316,11 @@
 		return -ENODEV;
 	}
 
+	if (spi->dev.platform_data)
+		pdata = spi->dev.platform_data;
+	else
+		pdata = ads7846_probe_dt(&spi->dev);
+
 	if (!pdata) {
 		dev_dbg(&spi->dev, "no platform data?\n");
 		return -ENODEV;
@@ -1245,21 +1351,29 @@
 		goto err_free_mem;
 	}
 
-	spi_set_drvdata(spi, ts);
+	dev_set_drvdata(&spi->dev, ts);
 
+	ts->pdata = pdata;
 	ts->packet = packet;
 	ts->spi = spi;
 	ts->input = input_dev;
-	ts->vref_mv = pdata->vref_mv;
-	ts->swap_xy = pdata->swap_xy;
 
 	mutex_init(&ts->lock);
 	init_waitqueue_head(&ts->wait);
 
-	ts->model = pdata->model ? : 7846;
-	ts->vref_delay_usecs = pdata->vref_delay_usecs ? : 100;
-	ts->x_plate_ohms = pdata->x_plate_ohms ? : 400;
-	ts->pressure_max = pdata->pressure_max ? : ~0;
+	/* pdata fallback defaults */
+
+	if (!pdata->model)
+		pdata->model = 7846;
+
+	if (!pdata->vref_delay_usecs)
+		pdata->vref_delay_usecs = 100;
+
+	if (!pdata->x_plate_ohms)
+		pdata->x_plate_ohms = 400;
+
+	if (!pdata->pressure_max)
+		pdata->pressure_max = ~0;
 
 	if (pdata->filter != NULL) {
 		if (pdata->filter_init != NULL) {
@@ -1397,7 +1511,7 @@
 
 static int ads7846_remove(struct spi_device *spi)
 {
-	struct ads7846 *ts = spi_get_drvdata(spi);
+	struct ads7846 *ts = dev_get_drvdata(&spi->dev);
 
 	device_init_wakeup(&spi->dev, false);
 
@@ -1437,6 +1551,7 @@
 		.name	= "ads7846",
 		.owner	= THIS_MODULE,
 		.pm	= &ads7846_pm,
+		.of_match_table = of_match_ptr(ads7846_dt_ids),
 	},
 	.probe		= ads7846_probe,
 	.remove		= ads7846_remove,
diff -urN fsl/drivers/media/pci/Kconfig sk/drivers/media/pci/Kconfig
--- fsl/drivers/media/pci/Kconfig	2014-09-18 21:48:51.000000000 +0400
+++ sk/drivers/media/pci/Kconfig	2015-02-18 14:34:17.000000000 +0300
@@ -12,6 +12,7 @@
 	comment "Media capture support"
 source "drivers/media/pci/meye/Kconfig"
 source "drivers/media/pci/sta2x11/Kconfig"
+source "drivers/media/pci/tw6869/Kconfig"
 endif
 
 if MEDIA_ANALOG_TV_SUPPORT
diff -urN fsl/drivers/media/pci/Makefile sk/drivers/media/pci/Makefile
--- fsl/drivers/media/pci/Makefile	2014-09-18 21:48:51.000000000 +0400
+++ sk/drivers/media/pci/Makefile	2015-02-18 14:52:07.000000000 +0300
@@ -24,3 +24,4 @@
 obj-$(CONFIG_VIDEO_SAA7164) += saa7164/
 obj-$(CONFIG_VIDEO_MEYE) += meye/
 obj-$(CONFIG_STA2X11_VIP) += sta2x11/
+obj-$(CONFIG_VIDEO_TW6869) += tw6869/
diff -urN fsl/drivers/media/pci/tw6869/Kconfig sk/drivers/media/pci/tw6869/Kconfig
--- fsl/drivers/media/pci/tw6869/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ sk/drivers/media/pci/tw6869/Kconfig	2015-02-13 01:14:49.000000000 +0300
@@ -0,0 +1,9 @@
+config VIDEO_TW6869
+	tristate "Techwell tw6869 Video For Linux"
+	depends on VIDEO_DEV && PCI && VIDEO_V4L2
+	select VIDEOBUF2_DMA_CONTIG
+	---help---
+	  Support for Techwell tw6869 based frame grabber boards.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tw6869.
diff -urN fsl/drivers/media/pci/tw6869/Makefile sk/drivers/media/pci/tw6869/Makefile
--- fsl/drivers/media/pci/tw6869/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ sk/drivers/media/pci/tw6869/Makefile	2015-02-13 01:14:49.000000000 +0300
@@ -0,0 +1 @@
+obj-$(CONFIG_VIDEO_TW6869) += tw6869.o
diff -urN fsl/drivers/media/pci/tw6869/tw6869.c sk/drivers/media/pci/tw6869/tw6869.c
--- fsl/drivers/media/pci/tw6869/tw6869.c	1970-01-01 03:00:00.000000000 +0300
+++ sk/drivers/media/pci/tw6869/tw6869.c	2015-02-20 13:52:32.000000000 +0300
@@ -0,0 +1,1389 @@
+/*
+ * Copyright 2015 www.starterkit.ru <info@starterkit.ru>
+ *
+ * Based on:
+ * Driver for Intersil|Techwell TW6869 based DVR cards
+ * (c) 2011-12 liran <jli11@intersil.com> [Intersil|Techwell China]
+ *
+ * V4L2 PCI Skeleton Driver
+ * Copyright 2014 Cisco Systems, Inc. and/or its affiliates.
+ * All rights reserved.
+ *
+ * This program is free software; you may redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/mutex.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/control.h>
+
+#include "tw6869.h"
+
+MODULE_DESCRIPTION("tw6869/65 media bridge driver");
+MODULE_AUTHOR("starterkit <info@starterkit.ru>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("0.3");
+
+static const struct pci_device_id tw6869_pci_tbl[] = {
+	{PCI_DEVICE(PCI_VENDOR_ID_TECHWELL, PCI_DEVICE_ID_6869)},
+	{ 0, }
+};
+
+struct tw6869_buf {
+	struct vb2_buffer vb;
+	struct list_head list;
+	dma_addr_t dma;
+};
+
+/**
+ * struct tw6869_ach - instance of one audio channel
+ * @dev: parent device
+ * @ss: audio channel (pcm substream)
+ * @id: DMA id
+ * @p_buf: DMA P-buffer
+ * @b_buf: DMA B-buffer
+ * @pb: P-buffer | B-buffer ping-pong state
+ * @ptr: PCM buffer pointer
+ * @buf: split an contiguous buffer into chunks
+ * @buf_list: chunk list
+ * @lock: spinlock controlling access to channel
+ */
+struct tw6869_ach {
+	struct tw6869_dev *dev;
+	struct snd_pcm_substream *ss;
+	unsigned int id;
+	struct tw6869_buf *p_buf;
+	struct tw6869_buf *b_buf;
+	unsigned int pb;
+
+	dma_addr_t ptr;
+
+	struct tw6869_buf buf[TW_APAGE_MAX];
+	struct list_head buf_list;
+	spinlock_t lock;
+};
+
+/**
+ * struct tw6869_vch - instance of one video channel
+ * @dev: parent device
+ * @vdev: video channel (v4l2 video device)
+ * @id: DMA id
+ * @p_buf: DMA P-buffer
+ * @b_buf: DMA B-buffer
+ * @pb: P-buffer | B-buffer ping-pong state
+ * @hdl: handler for control framework
+ * @format: pixel format
+ * @std: video standard (e.g. PAL/NTSC)
+ * @input: input line for video signal
+ * @queue: queue maintained by videobuf2 layer
+ * @buff_list: list of buffer in use
+ * @lock: spinlock controlling access to channel
+ * @sequence: sequence number of acquired buffer
+ * @dcount: number of dropped frames
+ * @fps: current frame rate
+ */
+struct tw6869_vch {
+	struct tw6869_dev *dev;
+	struct video_device vdev;
+	unsigned int id;
+	struct tw6869_buf *p_buf;
+	struct tw6869_buf *b_buf;
+	unsigned int pb;
+
+	struct v4l2_ctrl_handler hdl;
+	struct v4l2_pix_format format;
+	v4l2_std_id std;
+	unsigned int input;
+
+	struct vb2_queue queue;
+	struct list_head buf_list;
+	spinlock_t lock;
+
+	unsigned int sequence;
+	unsigned int dcount;
+	unsigned int fps;
+};
+
+/**
+ * struct tw6869_dev - instance of device
+ * @pdev: PCI device
+ * @bmmio: hardware base address
+ * @rlock: spinlock controlling access to registers
+ * @ch_max: channels used
+ * @v4l2_dev: device registered in v4l2 layer
+ * @vch: array of video channel instance
+ * @alloc_ctx: context for videobuf2
+ * @snd_card: device registered in ALSA layer
+ * @ach: array of audio channel instance
+ */
+struct tw6869_dev {
+	struct pci_dev *pdev;
+	unsigned char __iomem *mmio;
+	spinlock_t rlock;
+	unsigned int ch_max;
+
+	struct v4l2_device v4l2_dev;
+	struct tw6869_vch vch[TW_CH_MAX];
+	struct vb2_alloc_ctx *alloc_ctx;
+
+	struct snd_card *snd_card;
+	struct tw6869_ach ach[TW_CH_MAX];
+};
+
+/**********************************************************************/
+
+static inline void tw_write(struct tw6869_dev *dev, unsigned int reg,
+		unsigned int val)
+{
+	iowrite32(val, dev->mmio + reg);
+}
+
+static inline unsigned int tw_read(struct tw6869_dev *dev,
+		unsigned int reg)
+{
+	return ioread32(dev->mmio + reg);
+}
+
+static inline void tw_write_mask(struct tw6869_dev *dev,
+		unsigned int reg, unsigned int val, unsigned int mask)
+{
+	unsigned int v = tw_read(dev, reg);
+
+	v = (v & ~mask) | (val & mask);
+	tw_write(dev, reg, v);
+}
+
+static inline void tw_clear(struct tw6869_dev *dev,
+		unsigned int reg, unsigned int val)
+{
+	tw_write_mask(dev, reg, 0, val);
+}
+
+static inline void tw_set(struct tw6869_dev *dev,
+		unsigned int reg, unsigned int val)
+{
+	tw_write_mask(dev, reg, val, val);
+}
+
+static void tw6869_id_dma_cmd(struct tw6869_dev *dev,
+				unsigned int id,
+				unsigned int cmd)
+{
+	switch (cmd) {
+	case TW_DMA_ON:
+		dev_info(&dev->pdev->dev, "DMA id = %u: ON\n", id);
+		tw_set(dev, R32_DMA_CHANNEL_ENABLE, BIT(id));
+		tw_set(dev, R32_DMA_CMD, BIT(31) | BIT(id));
+		tw_read(dev, R32_DMA_CHANNEL_ENABLE);
+		tw_read(dev, R32_DMA_CMD);
+		break;
+	case TW_DMA_OFF:
+		dev_info(&dev->pdev->dev, "DMA id = %u: OFF\n", id);
+		tw_clear(dev, R32_DMA_CHANNEL_ENABLE, BIT(id));
+		tw_clear(dev, R32_DMA_CMD, BIT(id));
+		if (!tw_read(dev, R32_DMA_CHANNEL_ENABLE))
+			tw_write(dev, R32_DMA_CMD, 0);
+		tw_read(dev, R32_DMA_CMD);
+		break;
+	case TW_DMA_RST:
+		if (tw_read(dev, R32_DMA_CHANNEL_ENABLE) &
+			tw_read(dev, R32_DMA_CMD) & BIT(id)) {
+			dev_info(&dev->pdev->dev, "DMA id = %u: RST\n", id);
+			tw_clear(dev, R32_DMA_CHANNEL_ENABLE, BIT(id));
+			tw_clear(dev, R32_DMA_CMD, BIT(id));
+
+			tw_read(dev, R32_DMA_CHANNEL_ENABLE);
+			tw_read(dev, R32_DMA_CMD);
+			tw_read(dev, R32_DMA_P_ADDR(id));
+			tw_read(dev, R32_DMA_B_ADDR(id));
+
+			tw_set(dev, R32_DMA_CHANNEL_ENABLE, BIT(id));
+			tw_set(dev, R32_DMA_CMD, BIT(31) | BIT(id));
+			tw_read(dev, R32_DMA_CHANNEL_ENABLE);
+			tw_read(dev, R32_DMA_CMD);
+		}
+		break;
+	default:
+		dev_err(&dev->pdev->dev, "DMA %u unknown cmd %u\n", id, cmd);
+	}
+}
+
+static unsigned int tw6869_virq(struct tw6869_dev *dev,
+				unsigned int id,
+				unsigned int pb,
+				unsigned int err)
+{
+	struct tw6869_vch *vch = &dev->vch[ID2CH(id)];
+	struct tw6869_buf *done = NULL;
+	struct tw6869_buf *next = NULL;
+
+	spin_lock(&vch->lock);
+	if (!vch->p_buf || !vch->b_buf) {
+		spin_unlock(&vch->lock);
+		return TW_DMA_OFF;
+	}
+
+	if (err || (vch->pb != pb)) {
+		vch->pb = 0;
+		spin_unlock(&vch->lock);
+		return TW_DMA_RST;
+	}
+
+	if (!list_empty(&vch->buf_list)) {
+		next = list_first_entry(&vch->buf_list, struct tw6869_buf, list);
+		list_del(&next->list);
+		if (pb) {
+			done = vch->b_buf;
+			vch->b_buf = next;
+		} else {
+			done = vch->p_buf;
+			vch->p_buf = next;
+		}
+	}
+	vch->pb = !pb;
+	spin_unlock(&vch->lock);
+
+	if (done && next) {
+		tw_write(dev, pb ? R32_DMA_B_ADDR(id) : R32_DMA_P_ADDR(id), next->dma);
+		v4l2_get_timestamp(&done->vb.v4l2_buf.timestamp);
+		done->vb.v4l2_buf.sequence = vch->sequence++;
+		vb2_buffer_done(&done->vb, VB2_BUF_STATE_DONE);
+	} else {
+		dev_info(&dev->pdev->dev, "vch%u NOBUF seq=%u dcount=%u\n",
+			ID2CH(id), vch->sequence, ++vch->dcount);
+	}
+	return 0;
+}
+
+static unsigned int tw6869_airq(struct tw6869_dev *dev,
+				unsigned int id,
+				unsigned int pb)
+{
+	struct tw6869_ach *ach = &dev->ach[ID2CH(id)];
+	struct tw6869_buf *done = NULL;
+	struct tw6869_buf *next = NULL;
+
+	spin_lock(&ach->lock);
+	if (!ach->ss || !ach->p_buf || !ach->b_buf) {
+		spin_unlock(&ach->lock);
+		return TW_DMA_OFF;
+	}
+
+	if (ach->pb != pb) {
+		ach->pb = 0; 
+		spin_unlock(&ach->lock);
+		return TW_DMA_RST;
+	}
+
+	if (!list_empty(&ach->buf_list)) {
+		next = list_first_entry(&ach->buf_list, struct tw6869_buf, list);
+		list_move_tail(&next->list, &ach->buf_list);
+		if (pb) {
+			done = ach->p_buf;
+			ach->b_buf = next;
+		} else {
+			done = ach->b_buf;
+			ach->p_buf = next;
+		}
+	}
+	ach->pb = !pb;
+	spin_unlock(&ach->lock);
+
+	if (done && next) {
+		tw_write(dev, pb ? R32_DMA_B_ADDR(id) : R32_DMA_P_ADDR(id), next->dma);
+		ach->ptr = done->dma - ach->buf[0].dma;
+		snd_pcm_period_elapsed(ach->ss);
+	} else {
+		return TW_DMA_OFF;
+	}
+	return 0;
+}
+
+static irqreturn_t tw6869_irq(int irq, void *dev_id)
+{
+	struct tw6869_dev *dev = dev_id;
+	unsigned int int_sts, fifo_sts, pb_sts, pars_sts, dma_cmd, id;
+
+	int_sts = tw_read(dev, R32_INT_STATUS);
+	fifo_sts = tw_read(dev, R32_FIFO_STATUS);
+	pb_sts = tw_read(dev, R32_PB_STATUS);
+	pars_sts = tw_read(dev, R32_VIDEO_PARSER_STATUS);
+	dma_cmd = tw_read(dev, R32_DMA_CMD);
+
+	for (id = 0; id < (2 * TW_CH_MAX); id++) {
+		unsigned int verr = fifo_sts & TW_FIFO_ERR(id);
+
+		if ((dma_cmd & int_sts & BIT(id)) || verr) {
+			unsigned int cmd = (BIT(id) & TW_VID) ?
+				tw6869_virq(dev, id, !!(pb_sts & BIT(id)), verr) :
+				tw6869_airq(dev, id, !!(pb_sts & BIT(id)));
+			if (cmd) {
+				spin_lock(&dev->rlock);
+				tw6869_id_dma_cmd(dev, id, cmd);
+				spin_unlock(&dev->rlock);
+			}
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+/**********************************************************************/
+
+static inline struct tw6869_buf *to_tw6869_buf(struct vb2_buffer *vb2)
+{
+	return container_of(vb2, struct tw6869_buf, vb);
+}
+
+static int to_tw6869_pixformat(unsigned int pixelformat)
+{
+	int ret;
+
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_YUYV:
+		ret = TW_FMT_YUYV;
+		break;
+	case V4L2_PIX_FMT_UYVY:
+		ret = TW_FMT_UYVY;
+		break;
+	case V4L2_PIX_FMT_RGB565:
+		ret = TW_FMT_RGB565;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static unsigned int tw6869_fields_map(v4l2_std_id std, unsigned int rate)
+{
+	unsigned int map[15] = {
+		0x00000000, 0x00000001, 0x00004001, 0x00104001, 0x00404041,
+		0x01041041, 0x01104411, 0x01111111, 0x04444445, 0x04511445,
+		0x05145145, 0x05151515, 0x05515455, 0x05551555, 0x05555555
+	};
+	unsigned int std_625_50[26] = {
+		0, 1, 1, 2,  3,  3,  4,  4,  5,  5,  6,  7,  7,
+		   8, 8, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 0
+	};
+	unsigned int std_525_60[31] = {
+		0, 1, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7, 7,
+		   8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 0
+	};
+	unsigned int i =
+		(std & V4L2_STD_625_50) ? std_625_50[rate] : std_525_60[rate];
+
+	return map[i];
+}
+
+static void tw6869_fill_pix_format(struct tw6869_vch *vch,
+				struct v4l2_pix_format *pix)
+{
+	pix->width = 720;
+	pix->height = (vch->std & V4L2_STD_625_50) ? 576 : 480;
+	pix->field = V4L2_FIELD_INTERLACED_BT;
+	pix->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	pix->bytesperline = pix->width * 2;
+	pix->sizeimage = pix->bytesperline * pix->height;
+	pix->priv = 0;
+}
+
+static void tw6869_vch_set_dma(struct tw6869_vch *vch)
+{
+	struct tw6869_dev *dev = vch->dev;
+	struct v4l2_pix_format *pix = &vch->format;
+	unsigned int id = vch->id;
+	unsigned int cfg;
+
+	vch->fps = (vch->std & V4L2_STD_625_50) ? 25 : 30;
+	tw_write(dev, R32_VIDEO_FIELD_CTRL(id), 0);
+
+	if (vch->std & V4L2_STD_625_50)
+		tw_set(dev, R32_VIDEO_CONTROL1, BIT(ID2CH(id)) << 13);
+	else
+		tw_clear(dev, R32_VIDEO_CONTROL1, BIT(ID2CH(id)) << 13);
+
+	cfg = BIT(27) | ((to_tw6869_pixformat(pix->pixelformat) & 0x7) << 20);
+	tw_write(dev, R32_DMA_CHANNEL_CONFIG(id), cfg);
+
+	cfg = (((pix->height >> 1) & 0x3FF) << 22) |
+		((pix->bytesperline & 0x7FF) << 11) |
+		(pix->bytesperline & 0x7FF);
+	tw_write(dev, R32_DMA_WHP(id), cfg);
+}
+
+/*
+ * Videobuf2 Operations
+ */
+static int queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,
+				unsigned int *nbuffers, unsigned int *nplanes,
+				unsigned int sizes[], void *alloc_ctxs[])
+{
+	struct tw6869_vch *vch = vb2_get_drv_priv(vq);
+	struct tw6869_dev *dev = vch->dev;
+
+	if (vq->num_buffers + *nbuffers < TW_FRAME_MAX)
+		*nbuffers = TW_FRAME_MAX - vq->num_buffers;
+
+	if (fmt && fmt->fmt.pix.sizeimage < vch->format.sizeimage)
+		return -EINVAL;
+	*nplanes = 1;
+	sizes[0] = fmt ? fmt->fmt.pix.sizeimage : vch->format.sizeimage;
+	alloc_ctxs[0] = dev->alloc_ctx;
+	return 0;
+}
+
+static int buffer_init(struct vb2_buffer *vb)
+{
+	struct tw6869_buf *buf = to_tw6869_buf(vb);
+
+	buf->dma = vb2_dma_contig_plane_dma_addr(vb, 0);
+	INIT_LIST_HEAD(&buf->list);
+	{	/* this hack to make gst-fsl-plugins happy */
+		unsigned int *cpu = vb2_plane_vaddr(vb, 0);
+		*cpu = buf->dma;
+	}
+	return 0;
+}
+
+static int buffer_prepare(struct vb2_buffer *vb)
+{
+	struct tw6869_vch *vch = vb2_get_drv_priv(vb->vb2_queue);
+	struct tw6869_dev *dev = vch->dev;
+	struct tw6869_buf *buf = to_tw6869_buf(vb);
+	unsigned long size = vch->format.sizeimage;
+
+	if (vb2_plane_size(vb, 0) < size) {
+		v4l2_err(&dev->v4l2_dev, "buffer too small (%lu < %lu)\n",
+			vb2_plane_size(vb, 0), size);
+		return -EINVAL;
+	}
+	vb2_set_plane_payload(&buf->vb, 0, size);
+	return 0;
+}
+
+static void buffer_queue(struct vb2_buffer *vb)
+{
+	struct tw6869_vch *vch = vb2_get_drv_priv(vb->vb2_queue);
+	struct tw6869_buf *buf = to_tw6869_buf(vb);
+	unsigned long flags;
+
+	spin_lock_irqsave(&vch->lock, flags);
+	list_add_tail(&buf->list, &vch->buf_list);
+	spin_unlock_irqrestore(&vch->lock, flags);
+}
+
+static int start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	struct tw6869_vch *vch = vb2_get_drv_priv(vq);
+	struct tw6869_dev *dev = vch->dev;
+	struct tw6869_buf *p_buf, *b_buf;
+	unsigned long flags;
+
+	spin_lock_irqsave(&vch->lock, flags);
+	if (list_empty(&vch->buf_list) ||
+			(vch->buf_list.prev == vch->buf_list.next)) {
+		spin_unlock_irqrestore(&vch->lock, flags);
+		return -ENOBUFS;
+	}
+
+	p_buf = list_first_entry(&vch->buf_list, struct tw6869_buf, list);
+	list_del(&p_buf->list);
+	vch->p_buf = p_buf;
+	tw_write(dev, R32_DMA_P_ADDR(vch->id), p_buf->dma);
+
+	b_buf = list_first_entry(&vch->buf_list, struct tw6869_buf, list);
+	list_del(&b_buf->list);
+	vch->b_buf = b_buf;
+	tw_write(dev, R32_DMA_B_ADDR(vch->id), b_buf->dma);
+
+	vch->sequence = 0;
+	vch->dcount = 0;
+	vch->pb = 0;
+	spin_unlock_irqrestore(&vch->lock, flags);
+
+	spin_lock_irqsave(&dev->rlock, flags);
+	tw6869_id_dma_cmd(dev, vch->id, TW_DMA_ON);
+	spin_unlock_irqrestore(&dev->rlock, flags);
+
+	return 0;
+}
+
+static int stop_streaming(struct vb2_queue *vq)
+{
+	struct tw6869_vch *vch = vb2_get_drv_priv(vq);
+	struct tw6869_dev *dev = vch->dev;
+	struct tw6869_buf *buf, *node;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->rlock, flags);
+	tw6869_id_dma_cmd(dev, vch->id, TW_DMA_OFF);
+	spin_unlock_irqrestore(&dev->rlock, flags);
+
+	spin_lock_irqsave(&vch->lock, flags);
+	if (vch->p_buf) {
+		buf = vch->p_buf;
+		vch->p_buf = NULL;
+		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+	}
+
+	if (vch->b_buf) {
+		buf = vch->b_buf;
+		vch->b_buf = NULL;
+		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+	}
+
+	list_for_each_entry_safe(buf, node, &vch->buf_list, list) {
+		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+		list_del(&buf->list);
+	}
+	spin_unlock_irqrestore(&vch->lock, flags);
+
+	return 0;
+}
+
+static struct vb2_ops tw6869_qops = {
+	.queue_setup		= queue_setup,
+	.buf_init		= buffer_init,
+	.buf_prepare		= buffer_prepare,
+	.buf_queue		= buffer_queue,
+	.start_streaming	= start_streaming,
+	.stop_streaming		= stop_streaming,
+};
+
+static int tw6869_querycap(struct file *file, void *priv,
+				struct v4l2_capability *cap)
+{
+	struct tw6869_vch *vch = video_drvdata(file);
+	struct tw6869_dev *dev = vch->dev;
+
+	strlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));
+	snprintf(cap->card, sizeof(cap->card), "tw6869 vch%u", ID2CH(vch->id));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "PCI:%s",
+		pci_name(dev->pdev));
+	cap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |
+		V4L2_CAP_STREAMING;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+	return 0;
+}
+
+static int tw6869_try_fmt_vid_cap(struct file *file, void *priv,
+				struct v4l2_format *f)
+{
+	struct tw6869_vch *vch = video_drvdata(file);
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	int ret;
+
+	ret = to_tw6869_pixformat(pix->pixelformat);
+	if (ret < 0)
+		return ret;
+
+	tw6869_fill_pix_format(vch, pix);
+	return 0;
+}
+
+static int tw6869_s_fmt_vid_cap(struct file *file, void *priv,
+				struct v4l2_format *f)
+{
+	struct tw6869_vch *vch = video_drvdata(file);
+	int ret;
+
+	ret = tw6869_try_fmt_vid_cap(file, priv, f);
+	if (ret)
+		return ret;
+
+	if (vb2_is_busy(&vch->queue))
+		return -EBUSY;
+
+	vch->format = f->fmt.pix;
+	tw6869_vch_set_dma(vch);
+	return 0;
+}
+
+static int tw6869_g_fmt_vid_cap(struct file *file, void *priv,
+				struct v4l2_format *f)
+{
+	struct tw6869_vch *vch = video_drvdata(file);
+
+	f->fmt.pix = vch->format;
+	return 0;
+}
+
+static int tw6869_enum_fmt_vid_cap(struct file *file, void *priv,
+				struct v4l2_fmtdesc *f)
+{
+	if (f->index > 2)
+		return -EINVAL;
+
+	switch (f->index) {
+	case 1:
+		strcpy(f->description, "4:2:2, packed, YUYV");
+		f->pixelformat = V4L2_PIX_FMT_YUYV;
+		break;
+	case 2:
+		strcpy(f->description, "16 bpp RGB, le");
+		f->pixelformat = V4L2_PIX_FMT_RGB565;
+		break;
+	default:
+		strcpy(f->description, "4:2:2, packed, UYVY");
+		f->pixelformat = V4L2_PIX_FMT_UYVY;
+	}
+	f->flags = 0;
+	return 0;
+}
+
+static int tw6869_querystd(struct file *file, void *priv, v4l2_std_id *std)
+{
+	struct tw6869_vch *vch = video_drvdata(file);
+	struct tw6869_dev *dev = vch->dev;
+	unsigned int std_now;
+	char *std_str;
+
+	std_now = tw_read(dev, R8_STANDARD_SEL(vch->id));
+	std_now &= (0x07 << 4);
+	std_now >>= 4;
+
+	switch (std_now) {
+	case TW_STD_PAL_M:
+		std_str = "PAL (M)";
+		*std = V4L2_STD_525_60;
+		break;
+	case TW_STD_PAL_60:
+		std_str = "PAL 60";
+		*std = V4L2_STD_525_60;
+		break;
+	case TW_STD_NTSC_M:
+		std_str = "NTSC (M)";
+		*std = V4L2_STD_525_60;
+		break;
+	case TW_STD_NTSC_443:
+		std_str = "NTSC 4.43";
+		*std = V4L2_STD_525_60;
+		break;
+	case TW_STD_PAL:
+		std_str = "PAL (B,D,G,H,I)";
+		*std = V4L2_STD_625_50;
+		break;
+	case TW_STD_PAL_CN:
+		std_str = "PAL (CN)";
+		*std = V4L2_STD_625_50;
+		break;
+	case TW_STD_SECAM:
+		std_str = "SECAM";
+		*std = V4L2_STD_625_50;
+		break;
+	default:
+		std_str = "Not valid";
+		*std = 0;
+	}
+	v4l2_info(&dev->v4l2_dev, "vch%u current standard: %s\n",
+		ID2CH(vch->id), std_str);
+	return 0;
+}
+
+static int tw6869_s_std(struct file *file, void *priv, v4l2_std_id std)
+{
+	struct tw6869_vch *vch = video_drvdata(file);
+	v4l2_std_id new_std = (std & V4L2_STD_625_50) ?
+				V4L2_STD_625_50 : V4L2_STD_525_60;
+
+	if (new_std == vch->std)
+		return 0;
+
+	if (vb2_is_busy(&vch->queue))
+		return -EBUSY;
+
+	vch->std = new_std;
+	tw6869_fill_pix_format(vch, &vch->format);
+	tw6869_vch_set_dma(vch);
+	return 0;
+}
+
+static int tw6869_g_std(struct file *file, void *priv, v4l2_std_id *std)
+{
+	struct tw6869_vch *vch = video_drvdata(file);
+	v4l2_std_id new_std = 0;
+
+	tw6869_querystd(file, priv, &new_std);
+	if (new_std)
+		tw6869_s_std(file, priv, new_std);
+
+	*std = vch->std;
+	return 0;
+}
+
+static int tw6869_enum_input(struct file *file, void *priv,
+				struct v4l2_input *i)
+{
+	if (i->index < TW_VIN_MAX) {
+		i->type = V4L2_INPUT_TYPE_CAMERA;
+		i->std = V4L2_STD_ALL;
+		sprintf(i->name, "Camera %d", i->index);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+/* TODO */
+static int tw6869_s_input(struct file *file, void *priv, unsigned int i)
+{
+	struct tw6869_vch *vch = video_drvdata(file);
+
+	vch->input = i;
+	return 0;
+}
+
+static int tw6869_g_input(struct file *file, void *priv, unsigned int *i)
+{
+	struct tw6869_vch *vch = video_drvdata(file);
+
+	*i = vch->input;
+	return 0;
+}
+
+static int tw6869_g_parm(struct file *file, void *priv,
+				struct v4l2_streamparm *sp)
+{
+	struct tw6869_vch *vch = video_drvdata(file);
+	struct v4l2_captureparm *cp = &sp->parm.capture;
+
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = vch->fps;
+	return 0;
+}
+
+static int tw6869_s_parm(struct file *file, void *priv,
+				struct v4l2_streamparm *sp)
+{
+	struct tw6869_vch *vch = video_drvdata(file);
+	struct v4l2_captureparm *cp = &sp->parm.capture;
+	unsigned int denominator = cp->timeperframe.denominator;
+	unsigned int numerator = cp->timeperframe.numerator;
+	unsigned int fps;
+
+	fps = (!numerator || !denominator) ? 0 : denominator / numerator;
+	if (vch->std & V4L2_STD_625_50)
+		fps = (!fps || fps > 25) ? 25 : fps;
+	else
+		fps = (!fps || fps > 30) ? 30 : fps;
+
+	if (vch->fps != fps) {
+		unsigned int map = tw6869_fields_map(vch->std, fps) << 1;
+		map |= map << 1;
+		if (map > 0)
+			map |= BIT(31);
+		tw_write(vch->dev, R32_VIDEO_FIELD_CTRL(vch->id), map);
+		vch->fps = fps;
+		v4l2_info(&vch->dev->v4l2_dev,
+			"vch%u fps = %u\n", ID2CH(vch->id), vch->fps);
+	}
+	return tw6869_g_parm(file, priv, sp);
+}
+
+/* The control handler. */
+static int tw6869_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct tw6869_vch *vch =
+		container_of(ctrl->handler, struct tw6869_vch, hdl);
+	struct tw6869_dev *dev = vch->dev;
+	unsigned int id = vch->id;
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		tw_write(dev, R8_BRIGHT_CTRL(id), ctrl->val);
+		break;
+	case V4L2_CID_CONTRAST:
+		tw_write(dev, R8_CONTRAST_CTRL(id), ctrl->val);
+		break;
+	case V4L2_CID_SATURATION:
+		tw_write(dev, R8_SAT_U_CTRL(id), ctrl->val);
+		tw_write(dev, R8_SAT_V_CTRL(id), ctrl->val);
+		break;
+	case V4L2_CID_HUE:
+		tw_write(dev, R8_HUE_CTRL(id), ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+/*
+ * File operations for the device
+ */
+static const struct v4l2_ctrl_ops tw6869_ctrl_ops = {
+	.s_ctrl = tw6869_s_ctrl,
+};
+
+static const struct v4l2_ioctl_ops tw6869_ioctl_ops = {
+	.vidioc_querycap = tw6869_querycap,
+	.vidioc_try_fmt_vid_cap = tw6869_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap = tw6869_s_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap = tw6869_g_fmt_vid_cap,
+	.vidioc_enum_fmt_vid_cap = tw6869_enum_fmt_vid_cap,
+
+	.vidioc_g_std = tw6869_g_std,
+	.vidioc_s_std = tw6869_s_std,
+	.vidioc_querystd = tw6869_querystd,
+
+	.vidioc_enum_input = tw6869_enum_input,
+	.vidioc_g_input = tw6869_g_input,
+	.vidioc_s_input = tw6869_s_input,
+
+	.vidioc_g_parm = tw6869_g_parm,
+	.vidioc_s_parm = tw6869_s_parm,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+
+	.vidioc_log_status = v4l2_ctrl_log_status,
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static const struct v4l2_file_operations tw6869_fops = {
+	.owner = THIS_MODULE,
+	.open = v4l2_fh_open,
+	.release = vb2_fop_release,
+	.unlocked_ioctl = video_ioctl2,
+	.read = vb2_fop_read,
+	.mmap = vb2_fop_mmap,
+	.poll = vb2_fop_poll,
+};
+
+static int tw6869_vch_register(struct tw6869_vch *vch)
+{
+	struct tw6869_dev *dev = vch->dev;
+	struct v4l2_ctrl_handler *hdl = &vch->hdl;
+	struct vb2_queue *q = &vch->queue;
+	struct video_device *vdev = &vch->vdev;
+	int ret = 0;
+
+	/* Add the controls */
+	v4l2_ctrl_handler_init(hdl, 4);
+	v4l2_ctrl_new_std(hdl, &tw6869_ctrl_ops,
+		  V4L2_CID_BRIGHTNESS, -128, 127, 1, 0);
+	v4l2_ctrl_new_std(hdl, &tw6869_ctrl_ops,
+		  V4L2_CID_CONTRAST, 0, 255, 1, 100);
+	v4l2_ctrl_new_std(hdl, &tw6869_ctrl_ops,
+		  V4L2_CID_SATURATION, 0, 255, 1, 128);
+	v4l2_ctrl_new_std(hdl, &tw6869_ctrl_ops,
+		  V4L2_CID_HUE, -128, 127, 1, 0);
+	if (hdl->error) {
+		ret = hdl->error;
+		return ret;
+	}
+
+	/* Fill in the initial format-related settings */
+	vch->std = V4L2_STD_625_50;
+	vch->format.pixelformat = V4L2_PIX_FMT_UYVY;
+	tw6869_fill_pix_format(vch, &vch->format);
+	tw6869_vch_set_dma(vch);
+
+	/* Initialize the vb2 queue */
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ;
+	q->drv_priv = vch;
+	q->buf_struct_size = sizeof(struct tw6869_buf);
+	q->ops = &tw6869_qops;
+	q->mem_ops = &vb2_dma_contig_memops;
+	q->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->gfp_flags = __GFP_DMA32;
+	ret = vb2_queue_init(q);
+	if (ret)
+		goto free_hdl;
+
+	spin_lock_init(&vch->lock);
+	INIT_LIST_HEAD(&vch->buf_list);
+
+	/* Initialize the video_device structure */
+	strlcpy(vdev->name, KBUILD_MODNAME, sizeof(vdev->name));
+	vdev->release = video_device_release;
+	vdev->fops = &tw6869_fops,
+	vdev->ioctl_ops = &tw6869_ioctl_ops,
+	vdev->queue = q;
+	vdev->v4l2_dev = &dev->v4l2_dev;
+	vdev->ctrl_handler = hdl;
+	vdev->tvnorms = V4L2_STD_ALL;
+	video_set_drvdata(vdev, vch);
+	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+	if (!ret)
+		return 0;
+
+free_hdl:
+	v4l2_ctrl_handler_free(hdl);
+	return ret;
+}
+
+static void tw6869_video_unregister(struct tw6869_dev *dev)
+{
+	unsigned int ch;
+
+	if (dev->ch_max > TW_CH_MAX)
+		dev->ch_max = TW_CH_MAX;
+
+	/* Reset and disable all DMA channels */
+	tw_write(dev, R32_DMA_CMD, 0);
+	tw_write(dev, R32_DMA_CHANNEL_ENABLE, 0);
+
+	for (ch = 0; ch < dev->ch_max; ch++) {
+		struct tw6869_vch *vch = &dev->vch[ch];
+		video_unregister_device(&vch->vdev);
+		v4l2_ctrl_handler_free(&vch->hdl);
+	}
+	v4l2_device_unregister(&dev->v4l2_dev);
+	vb2_dma_contig_cleanup_ctx(dev->alloc_ctx);
+}
+
+static int tw6869_video_register(struct tw6869_dev *dev)
+{
+	struct pci_dev *pdev = dev->pdev;
+	unsigned int ch;
+	int ret;
+
+	/* Initialize the top-level structure */
+	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
+	if (ret)
+		return ret;
+
+	dev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);
+	if (IS_ERR(dev->alloc_ctx)) {
+		v4l2_err(&dev->v4l2_dev, "can't allocate buffer context\n");
+		ret = PTR_ERR(dev->alloc_ctx);
+		goto unreg_device;
+	}
+
+	for (ch = 0; ch < dev->ch_max; ch++) {
+		struct tw6869_vch *vch = &dev->vch[ch];
+		vch->dev = dev;
+		vch->id = ch;
+		ret = tw6869_vch_register(vch);
+		if (ret) {
+			dev->ch_max = ch;
+			tw6869_video_unregister(dev);
+			goto free_ctx;
+		}
+	}
+
+	return 0;
+
+free_ctx:
+	vb2_dma_contig_cleanup_ctx(dev->alloc_ctx);
+unreg_device:
+	v4l2_device_unregister(&dev->v4l2_dev);
+	return ret;
+}
+
+/**********************************************************************/
+
+static int tw6869_pcm_hw_params(struct snd_pcm_substream *ss,
+				struct snd_pcm_hw_params *hw_params)
+{
+	return snd_pcm_lib_malloc_pages(ss, params_buffer_bytes(hw_params));
+}
+
+static int tw6869_pcm_hw_free(struct snd_pcm_substream *ss)
+{
+	return snd_pcm_lib_free_pages(ss);
+}
+
+/* TODO: SNDRV_PCM_RATE_8000_48000 */
+static const struct snd_pcm_hardware tw6869_capture_hw = {
+	.info			= (SNDRV_PCM_INFO_MMAP |
+				   SNDRV_PCM_INFO_INTERLEAVED |
+				   SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				   SNDRV_PCM_INFO_MMAP_VALID),
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.rates			= SNDRV_PCM_RATE_48000,
+	.rate_min		= 48000,
+	.rate_max		= 48000,
+	.channels_min		= 1,
+	.channels_max		= 1,
+	.buffer_bytes_max	= TW_APAGE_MAX * TW_PAGE_SIZE,
+	.period_bytes_min	= TW_PAGE_SIZE,
+	.period_bytes_max	= TW_PAGE_SIZE,
+	.periods_min		= 2,
+	.periods_max		= TW_APAGE_MAX,
+};
+
+static int tw6869_pcm_open(struct snd_pcm_substream *ss)
+{
+	struct tw6869_dev *dev = snd_pcm_substream_chip(ss);
+	struct tw6869_ach *ach = &dev->ach[ss->number];
+	struct snd_pcm_runtime *rt = ss->runtime;
+	int ret;
+
+	ach->ss = ss;
+	rt->hw = tw6869_capture_hw;
+
+	ret = snd_pcm_hw_constraint_integer(rt, SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int tw6869_pcm_close(struct snd_pcm_substream *ss)
+{
+	struct tw6869_dev *dev = snd_pcm_substream_chip(ss);
+	struct tw6869_ach *ach = &dev->ach[ss->number];
+
+	ach->ss = NULL;
+	return 0;
+}
+
+static int tw6869_pcm_prepare(struct snd_pcm_substream *ss)
+{
+	struct tw6869_dev *dev = snd_pcm_substream_chip(ss);
+	struct tw6869_ach *ach = &dev->ach[ss->number];
+	struct snd_pcm_runtime *rt = ss->runtime;
+	unsigned int period = snd_pcm_lib_period_bytes(ss);
+	struct tw6869_buf *p_buf, *b_buf;
+	unsigned long flags;
+	unsigned int i;
+
+	spin_lock_irqsave(&dev->rlock, flags);
+	tw6869_id_dma_cmd(dev, ach->id, TW_DMA_OFF);
+	spin_unlock_irqrestore(&dev->rlock, flags);
+
+	spin_lock_irqsave(&ach->lock, flags);
+	INIT_LIST_HEAD(&ach->buf_list);
+
+	for (i = 0; i < rt->periods; i++) {
+		ach->buf[i].dma = rt->dma_addr + period * i;
+		INIT_LIST_HEAD(&ach->buf[i].list);
+		list_add_tail(&ach->buf[i].list, &ach->buf_list);
+	}
+
+	p_buf =	list_first_entry(&ach->buf_list, struct tw6869_buf, list);
+	list_move_tail(&p_buf->list, &ach->buf_list);
+	ach->p_buf = p_buf;
+	tw_write(dev, R32_DMA_P_ADDR(ach->id), p_buf->dma);
+
+	b_buf =	list_first_entry(&ach->buf_list, struct tw6869_buf, list);
+	list_move_tail(&b_buf->list, &ach->buf_list);
+	ach->b_buf = b_buf;
+	tw_write(dev, R32_DMA_B_ADDR(ach->id), b_buf->dma);
+
+	ach->ptr = 0;
+	ach->pb = 0;
+	spin_unlock_irqrestore(&ach->lock, flags);
+
+	return 0;
+}
+
+static int tw6869_pcm_trigger(struct snd_pcm_substream *ss, int cmd)
+{
+	struct tw6869_dev *dev = snd_pcm_substream_chip(ss);
+	struct tw6869_ach *ach = &dev->ach[ss->number];
+	unsigned long flags;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if (ach->p_buf && ach->b_buf) {
+			spin_lock_irqsave(&dev->rlock, flags);
+			tw6869_id_dma_cmd(dev, ach->id, TW_DMA_ON);
+			spin_unlock_irqrestore(&dev->rlock, flags);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		spin_lock_irqsave(&dev->rlock, flags);
+		tw6869_id_dma_cmd(dev, ach->id, TW_DMA_OFF);
+		spin_unlock_irqrestore(&dev->rlock, flags);
+
+		spin_lock_irqsave(&ach->lock, flags);
+		ach->p_buf = NULL;
+		ach->b_buf = NULL;
+		spin_unlock_irqrestore(&ach->lock, flags);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static snd_pcm_uframes_t tw6869_pcm_pointer(struct snd_pcm_substream *ss)
+{
+	struct tw6869_dev *dev = snd_pcm_substream_chip(ss);
+	struct tw6869_ach *ach = &dev->ach[ss->number];
+
+	return bytes_to_frames(ss->runtime, ach->ptr);
+}
+
+static struct snd_pcm_ops tw6869_pcm_ops = {
+	.open = tw6869_pcm_open,
+	.close = tw6869_pcm_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = tw6869_pcm_hw_params,
+	.hw_free = tw6869_pcm_hw_free,
+	.prepare = tw6869_pcm_prepare,
+	.trigger = tw6869_pcm_trigger,
+	.pointer = tw6869_pcm_pointer,
+};
+
+static int tw6869_snd_pcm_init(struct tw6869_dev *dev)
+{
+	struct snd_card *card = dev->snd_card;
+	struct snd_pcm *pcm;
+	struct snd_pcm_substream *ss;
+	unsigned int i;
+	int ret;
+
+	ret = snd_pcm_new(card, card->driver, 0, 0, dev->ch_max, &pcm);
+	if (ret < 0)
+		return ret;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &tw6869_pcm_ops);
+	snd_pcm_chip(pcm) = dev;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, card->shortname);
+
+	for (i = 0, ss = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;
+	     ss; ss = ss->next, i++)
+		sprintf(ss->name, "vch%u audio", i);
+
+	ret = snd_pcm_lib_preallocate_pages_for_all(pcm,
+				SNDRV_DMA_TYPE_DEV,
+				snd_dma_pci_data(dev->pdev),
+				TW_APAGE_MAX * TW_PAGE_SIZE,
+				TW_APAGE_MAX * TW_PAGE_SIZE);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void tw6869_audio_unregister(struct tw6869_dev *dev)
+{
+	if (!dev->snd_card)
+		return;
+
+	/* Reset and disable audio DMA */
+	tw_clear(dev, R32_DMA_CMD, TW_AID);
+	tw_clear(dev, R32_DMA_CHANNEL_ENABLE, TW_AID);
+
+	snd_card_free(dev->snd_card);
+	dev->snd_card = NULL;
+}
+
+/* TODO: mixer controls */
+static int tw6869_audio_register(struct tw6869_dev *dev)
+{
+	struct pci_dev *pdev = dev->pdev;
+	static struct snd_device_ops ops = { NULL };
+	struct snd_card *card;
+	unsigned int ch;
+	int ret;
+
+	ret = snd_card_create(SNDRV_DEFAULT_IDX1, KBUILD_MODNAME,
+				THIS_MODULE, 0, &card);
+	if (ret < 0)
+		return ret;
+
+	dev->snd_card = card;
+
+	for (ch = 0; ch < dev->ch_max; ch++) {
+		struct tw6869_ach *ach = &dev->ach[ch];
+		spin_lock_init(&ach->lock);
+		ach->dev = dev;
+		ach->id = TW_CH_MAX + ch;
+	}
+
+	strcpy(card->driver, KBUILD_MODNAME);
+	strcpy(card->shortname, KBUILD_MODNAME);
+	sprintf(card->longname, "%s on %s IRQ %d", card->shortname,
+		pci_name(pdev), pdev->irq);
+
+	ret = snd_device_new(card, SNDRV_DEV_LOWLEVEL, dev, &ops);
+	if (ret < 0)
+		goto snd_error;
+
+	snd_card_set_dev(card, &pdev->dev);
+
+	ret = tw6869_snd_pcm_init(dev);
+	if (ret < 0)
+		goto snd_error;
+
+	ret = snd_card_register(card);
+	if (ret < 0)
+		goto snd_error;
+
+	return 0;
+
+snd_error:
+	snd_card_free(card);
+	dev->snd_card = NULL;
+	return ret;
+}
+
+/**********************************************************************/
+
+static void tw6869_reset(struct tw6869_dev *dev)
+{
+	/* Software Reset */
+	tw_write(dev, R32_SYS_SOFT_RST, 0x01);
+	tw_write(dev, R32_SYS_SOFT_RST, 0x0F);
+
+	/* Reset Internal audio and video decoders */
+	tw_write(dev, R8_AVSRST(0), 0x1F);
+	tw_write(dev, R8_AVSRST(4), 0x1F);
+
+	/* Reset all DMA channels */
+	tw_write(dev, R32_DMA_CMD, 0);
+
+	/* Disable all DMA channels */
+	tw_write(dev, R32_DMA_CHANNEL_ENABLE, 0);
+
+	/* Enable DMA FIFO overflow and pointer check */
+	tw_write(dev, R32_DMA_CONFIG, 0x00FFFF04);
+
+	/* Minimum time span for DMA interrupting host (default: 0x00098968) */
+	tw_write(dev, R32_DMA_TIMER_INTERVAL, 0x00098968);
+
+	/* DMA timeout (default: 0x140C8584) */
+	tw_write(dev, R32_DMA_CHANNEL_TIMEOUT, 0x140C8584);
+
+	/* 625 lines, full D1 */
+	tw_write(dev, R32_VIDEO_CONTROL1, 0x001FE001);
+
+	/* Frame mode DMA */
+	tw_write(dev, R32_PHASE_REF, 0xAAAA144D);
+
+	/* Show blue background if no signal */
+	tw_write(dev, R8_MISC_CONTROL1(0), 0xE7);
+	tw_write(dev, R8_MISC_CONTROL1(4), 0xE7);
+
+	/* Audio sampling frequency reference 48 kHz */
+	tw_write(dev, R32_AUDIO_CONTROL1, 0x80000001 | (0x0A2C << 5));
+	tw_write(dev, R32_AUDIO_CONTROL2, 0x0A2C2AAA);
+}
+
+static int tw6869_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	struct tw6869_dev *dev;
+	int ret;
+
+	/* Allocate a new instance */
+	dev = devm_kzalloc(&pdev->dev, sizeof(struct tw6869_dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	/* Enable PCI */
+	ret = pci_enable_device(pdev);
+	if (ret)
+		return ret;
+
+	pci_set_master(pdev);
+	ret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
+	if (ret) {
+		dev_err(&pdev->dev, "no suitable DMA available\n");
+		goto disable_pci;
+	}
+
+	/* Get mmio */
+	ret = pci_request_regions(pdev, KBUILD_MODNAME);
+	if (ret)
+		goto disable_pci;
+
+	dev->mmio = pci_iomap(pdev, 0, 0);
+	if (!dev->mmio) {
+		ret = -EIO;
+		goto release_regs;
+	}
+
+	tw6869_reset(dev);
+
+	/* Allocate the interrupt */
+	ret = devm_request_irq(&pdev->dev, pdev->irq,
+				tw6869_irq, IRQF_SHARED, KBUILD_MODNAME, dev);
+	if (ret) {
+		dev_err(&pdev->dev, "request_irq failed\n");
+		goto unmap_regs;
+	}
+
+	dev->pdev = pdev;
+	/* TODO: check tw6869/65 */
+	dev->ch_max = TW_CH_MAX;
+	spin_lock_init(&dev->rlock);
+
+	ret = tw6869_video_register(dev);
+	if (ret)
+		goto unmap_regs;
+
+	ret = tw6869_audio_register(dev);
+	if (ret)
+		goto video_unreg;
+
+	dev_info(&pdev->dev, "driver loaded\n");
+	return 0;
+
+video_unreg:
+	tw6869_video_unregister(dev);
+unmap_regs:
+	pci_iounmap(pdev, dev->mmio);
+release_regs:
+	pci_release_regions(pdev);
+disable_pci:
+	pci_disable_device(pdev);
+	return ret;
+}
+
+static void tw6869_remove(struct pci_dev *pdev)
+{
+	struct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);
+	struct tw6869_dev *dev =
+		container_of(v4l2_dev, struct tw6869_dev, v4l2_dev);
+
+	tw6869_audio_unregister(dev);
+	tw6869_video_unregister(dev);
+	pci_iounmap(pdev, dev->mmio);
+	pci_release_regions(pdev);
+	pci_disable_device(dev->pdev);
+}
+
+/* TODO: PM */
+static struct pci_driver tw6869_driver = {
+	.name = KBUILD_MODNAME,
+	.probe = tw6869_probe,
+	.remove = tw6869_remove,
+	.id_table = tw6869_pci_tbl,
+};
+
+module_pci_driver(tw6869_driver);
diff -urN fsl/drivers/media/pci/tw6869/tw6869.h sk/drivers/media/pci/tw6869/tw6869.h
--- fsl/drivers/media/pci/tw6869/tw6869.h	1970-01-01 03:00:00.000000000 +0300
+++ sk/drivers/media/pci/tw6869/tw6869.h	2015-02-15 22:38:23.000000000 +0300
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2015 www.starterkit.ru <info@starterkit.ru>
+ *
+ * Based on:
+ * tw686x common header file
+ * Copyright 2009-10 liran <jlee@techwellinc.com.cn> [Techwell China]
+ *
+ * This program is free software; you may redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef __TW6869_H
+#define __TW6869_H
+
+#define PCI_VENDOR_ID_TECHWELL  0x1797
+#define PCI_DEVICE_ID_6869      0x6869
+
+#define ID2CH(did)        ((did) & 0x7)
+
+#define TW_FRAME_MAX      16
+#define TW_APAGE_MAX      16
+#define TW_CH_MAX         8
+#define TW_VIN_MAX        4
+#define TW_PAGE_SIZE      4096
+
+#define TW_VID            0x00FF
+#define TW_AID            0xFF00
+#define TW_CH0to3         0x0F
+#define TW_CH4to7         0xF0
+
+#define TW_DMA_ON         1
+#define TW_DMA_OFF        2
+#define TW_DMA_RST        3
+#define TW_DMA_DESC_UNIT  512
+#define TW_FIFO_ERR(did)  ((BIT(did) & TW_VID) ? ((BIT(ID2CH(did)) << 24) | (BIT(ID2CH(did)) << 16)) : 0)
+#define TW_PARS_ERR(did)  ((BIT(did) & TW_VID) ? ((BIT(ID2CH(did)) << 8)  | BIT(ID2CH(did))) : 0)
+
+#define TW_STD_NTSC_M     0
+#define TW_STD_PAL        1
+#define TW_STD_SECAM      2
+#define TW_STD_NTSC_443   3
+#define TW_STD_PAL_M      4
+#define TW_STD_PAL_CN     5
+#define TW_STD_PAL_60     6
+
+#define TW_FMT_UYVY       0
+#define TW_FMT_RGB565     5
+#define TW_FMT_YUYV       6
+
+/**
+ * Register definitions
+ */
+#define R32_INT_STATUS              0x000                        /* 0x00 */
+#define R32_PB_STATUS               0x004                        /* 0x01 */
+#define R32_DMA_CMD                 0x008                        /* 0x02 */
+#define R32_FIFO_STATUS             0x00C                        /* 0x03 */
+#define R32_VIDEO_CHANNEL_ID        0x010                        /* 0x04 */
+#define R32_VIDEO_PARSER_STATUS     0x014                        /* 0x05 */
+#define R32_SYS_SOFT_RST            0x018                        /* 0x06 */
+#define R32_DMA_CHANNEL_ENABLE      0x028                        /* 0x0a */
+#define R32_DMA_CONFIG              0x02C                        /* 0x0b */
+#define R32_DMA_TIMER_INTERVAL      0x030                        /* 0x0c */
+#define R32_DMA_CHANNEL_TIMEOUT     0x034                        /* 0x0d */
+#define R32_DMA_CHANNEL_CONFIG(did) (0x040 + ID2CH(did) * 0x04)  /* 0x10 */
+#define R32_VIDEO_CONTROL1          0x0A8                        /* 0x2A */
+#define R32_VIDEO_CONTROL2          0x0AC                        /* 0x2B */
+#define R32_AUDIO_CONTROL1          0x0B0                        /* 0x2C */
+#define R32_AUDIO_CONTROL2          0x0B4                        /* 0x2D */
+#define R32_PHASE_REF               0x0B8                        /* 0x2E */
+#define R32_VIDEO_FIELD_CTRL(did)   (0x0E4 + ID2CH(did) * 0x04)  /* 0x39 */
+#define R32_DMA_P_ADDR(did)         ((BIT(did) & TW_VID) ? (0x200 + ID2CH(did) * 0x20) : (0x060 + ID2CH(did) * 0x08))
+#define R32_DMA_B_ADDR(did)         ((BIT(did) & TW_VID) ? (0x208 + ID2CH(did) * 0x20) : (0x064 + ID2CH(did) * 0x08))
+#define R32_DMA_WHP(did)            (0x204 + ID2CH(did) * 0x20)  /* 0x81 */
+#define R32_F2_DMA_P_ADDR(did)      (0x210 + ID2CH(did) * 0x20)  /* 0x84 */
+#define R32_F2_DMA_B_ADDR(did)      (0x218 + ID2CH(did) * 0x20)  /* 0x86 */
+#define R32_F2_DMA_WHP(did)         (0x214 + ID2CH(did) * 0x20)  /* 0x85 */
+
+/* 0x101, 0x201 */
+#define R8_BRIGHT_CTRL(did)         (((BIT(ID2CH(did)) & TW_CH0to3) ? 0x404 : 0x804) + ((did) & 0x3) * 0x40)
+/* 0x102, 0x202 */
+#define R8_CONTRAST_CTRL(did)       (((BIT(ID2CH(did)) & TW_CH0to3) ? 0x408 : 0x808) + ((did) & 0x3) * 0x40)
+/* 0x104, 0x204 */
+#define R8_SAT_U_CTRL(did)          (((BIT(ID2CH(did)) & TW_CH0to3) ? 0x410 : 0x810) + ((did) & 0x3) * 0x40)
+/* 0x105, 0x205 */
+#define R8_SAT_V_CTRL(did)          (((BIT(ID2CH(did)) & TW_CH0to3) ? 0x414 : 0x814) + ((did) & 0x3) * 0x40)
+/* 0x106, 0x206 */
+#define R8_HUE_CTRL(did)            (((BIT(ID2CH(did)) & TW_CH0to3) ? 0x418 : 0x818) + ((did) & 0x3) * 0x40)
+/* 0x10E, 0x20E */
+#define R8_STANDARD_SEL(did)        (((BIT(ID2CH(did)) & TW_CH0to3) ? 0x438 : 0x838) + ((did) & 0x3) * 0x40)
+/* 0x180, 0x280 */
+#define R8_AVSRST(did)              ((BIT(ID2CH(did)) & TW_CH0to3) ? 0x600 : 0xA00)
+/* 0x196, 0x296 */
+#define R8_MISC_CONTROL1(did)       ((BIT(ID2CH(did)) & TW_CH0to3) ? 0x658 : 0xA58)
+/* 0x1D0, 0x2D0 */
+#define R8_AIGAIN_CTRL(did)         (((BIT(ID2CH(did)) & TW_CH0to3) ? 0x740 : 0xB40) + ((did) & 0x3) * 0x04)
+
+#endif /* __TW6869_H */
diff -urN fsl/drivers/media/platform/mxc/capture/adv7180.c sk/drivers/media/platform/mxc/capture/adv7180.c
--- fsl/drivers/media/platform/mxc/capture/adv7180.c	2014-09-18 21:48:51.000000000 +0400
+++ sk/drivers/media/platform/mxc/capture/adv7180.c	2014-12-12 20:17:45.000000000 +0300
@@ -71,6 +71,7 @@
 struct sensor {
 	struct sensor_data sen;
 	v4l2_std_id std_id;
+	u32	cam_std;
 } adv7180_data;
 
 
@@ -177,8 +178,10 @@
 
 static inline void adv7180_power_down(int enable)
 {
-	gpio_set_value_cansleep(pwn_gpio, !enable);
-	msleep(2);
+	if (gpio_is_valid(pwn_gpio)) {
+		gpio_set_value_cansleep(pwn_gpio, !enable);
+		msleep(2);
+	}
 }
 
 static int adv7180_regulator_enable(struct device *dev)
@@ -317,14 +320,13 @@
 	dev_dbg(&adv7180_data.sen.i2c_client->dev, "In adv7180_get_std\n");
 
 	/* Read the AD_RESULT to get the detect output video standard */
-	tmp = adv7180_read(ADV7180_STATUS_1) & 0x70;
-
+	tmp = adv7180_read(ADV7180_INPUT_CTL) & 0xf0;
 	mutex_lock(&mutex);
-	if (tmp == 0x40) {
+	if (tmp == 0x80) {
 		/* PAL */
 		*std = V4L2_STD_PAL;
 		idx = ADV7180_PAL;
-	} else if (tmp == 0) {
+	} else if ((tmp == 0x40) || (tmp == 0x50)) {
 		/*NTSC*/
 		*std = V4L2_STD_NTSC;
 		idx = ADV7180_NTSC;
@@ -377,8 +379,8 @@
 	memset(p, 0, sizeof(*p));
 	p->if_type = V4L2_IF_TYPE_BT656; /* This is the only possibility. */
 	p->u.bt656.mode = V4L2_IF_TYPE_BT656_MODE_NOBT_8BIT;
-	p->u.bt656.nobt_hs_inv = 1;
-	p->u.bt656.bt_sync_correct = 1;
+//	p->u.bt656.nobt_hs_inv = 1;
+//	p->u.bt656.bt_sync_correct = 1;
 
 	/* ADV7180 has a dedicated clock so no clock settings needed. */
 
@@ -783,6 +785,30 @@
 	return 0;
 }
 
+static int ioctl_s_video_routing(struct v4l2_int_device *s,
+			struct v4l2_routing *route)
+{
+	int timeout = 10;
+
+	/* Set CVBS input on AIN 1-6 */
+	adv7180_write_reg(ADV7180_INPUT_CTL, 
+		adv7180_data.cam_std | route->input);
+	dev_dbg(&adv7180_data.sen.i2c_client->dev, 
+		"AIN%d\n", route->input + 1);
+
+	msleep(1);
+
+	while ((adv7180_read(ADV7180_STATUS_1) & 0x01) == 0) {
+		if (!timeout--) {
+			dev_info(&adv7180_data.sen.i2c_client->dev, 
+				"cannot lock AIN%d\n", route->input + 1);
+			break;
+		}
+		msleep(10);
+	}
+	return 0;
+}
+
 /*!
  * ioctl_init - V4L2 sensor interface handler for VIDIOC_INT_INIT
  * @s: pointer to standard V4L2 device structure
@@ -857,6 +883,8 @@
 				(v4l2_int_ioctl_func *) ioctl_enum_framesizes},
 	{vidioc_int_g_chip_ident_num,
 				(v4l2_int_ioctl_func *)ioctl_g_chip_ident},
+	{vidioc_int_s_video_routing_num,
+				(v4l2_int_ioctl_func *)ioctl_s_video_routing},
 };
 
 static struct v4l2_int_slave adv7180_slave = {
@@ -889,254 +917,37 @@
 
 	if (cvbs) {
 		/* Set CVBS input on AIN1 */
-		adv7180_write_reg(ADV7180_INPUT_CTL, 0x00);
+		adv7180_write_reg(ADV7180_INPUT_CTL, adv7180_data.cam_std & 0xf0); 
 	} else {
 		/*
-		 * Set YPbPr input on AIN1,4,5 and normal
-		 * operations(autodection of all stds).
+		 * Set YPbPr input on AIN1,4,5
 		 */
-		adv7180_write_reg(ADV7180_INPUT_CTL, 0x09);
+		adv7180_write_reg(ADV7180_INPUT_CTL, adv7180_data.cam_std | 0x09);
 	}
 
-	/* Datasheet recommends */
-	adv7180_write_reg(0x01, 0xc8);
-	adv7180_write_reg(0x02, 0x04);
-	adv7180_write_reg(0x03, 0x00);
-	adv7180_write_reg(0x04, 0x45);
-	adv7180_write_reg(0x05, 0x00);
-	adv7180_write_reg(0x06, 0x02);
-	adv7180_write_reg(0x07, 0x7F);
-	adv7180_write_reg(0x08, 0x80);
-	adv7180_write_reg(0x0A, 0x00);
-	adv7180_write_reg(0x0B, 0x00);
-	adv7180_write_reg(0x0C, 0x36);
-	adv7180_write_reg(0x0D, 0x7C);
-	adv7180_write_reg(0x0E, 0x00);
-	adv7180_write_reg(0x0F, 0x00);
-	adv7180_write_reg(0x13, 0x00);
-	adv7180_write_reg(0x14, 0x12);
-	adv7180_write_reg(0x15, 0x00);
-	adv7180_write_reg(0x16, 0x00);
-	adv7180_write_reg(0x17, 0x01);
-	adv7180_write_reg(0x18, 0x93);
-	adv7180_write_reg(0xF1, 0x19);
-	adv7180_write_reg(0x1A, 0x00);
-	adv7180_write_reg(0x1B, 0x00);
-	adv7180_write_reg(0x1C, 0x00);
-	adv7180_write_reg(0x1D, 0x40);
-	adv7180_write_reg(0x1E, 0x00);
-	adv7180_write_reg(0x1F, 0x00);
-	adv7180_write_reg(0x20, 0x00);
-	adv7180_write_reg(0x21, 0x00);
-	adv7180_write_reg(0x22, 0x00);
-	adv7180_write_reg(0x23, 0xC0);
-	adv7180_write_reg(0x24, 0x00);
-	adv7180_write_reg(0x25, 0x00);
-	adv7180_write_reg(0x26, 0x00);
-	adv7180_write_reg(0x27, 0x58);
-	adv7180_write_reg(0x28, 0x00);
-	adv7180_write_reg(0x29, 0x00);
-	adv7180_write_reg(0x2A, 0x00);
-	adv7180_write_reg(0x2B, 0xE1);
-	adv7180_write_reg(0x2C, 0xAE);
-	adv7180_write_reg(0x2D, 0xF4);
-	adv7180_write_reg(0x2E, 0x00);
-	adv7180_write_reg(0x2F, 0xF0);
-	adv7180_write_reg(0x30, 0x00);
-	adv7180_write_reg(0x31, 0x12);
-	adv7180_write_reg(0x32, 0x41);
-	adv7180_write_reg(0x33, 0x84);
-	adv7180_write_reg(0x34, 0x00);
-	adv7180_write_reg(0x35, 0x02);
-	adv7180_write_reg(0x36, 0x00);
-	adv7180_write_reg(0x37, 0x01);
-	adv7180_write_reg(0x38, 0x80);
-	adv7180_write_reg(0x39, 0xC0);
-	adv7180_write_reg(0x3A, 0x10);
-	adv7180_write_reg(0x3B, 0x05);
-	adv7180_write_reg(0x3C, 0x58);
-	adv7180_write_reg(0x3D, 0xB2);
-	adv7180_write_reg(0x3E, 0x64);
-	adv7180_write_reg(0x3F, 0xE4);
-	adv7180_write_reg(0x40, 0x90);
-	adv7180_write_reg(0x41, 0x01);
-	adv7180_write_reg(0x42, 0x7E);
-	adv7180_write_reg(0x43, 0xA4);
-	adv7180_write_reg(0x44, 0xFF);
-	adv7180_write_reg(0x45, 0xB6);
-	adv7180_write_reg(0x46, 0x12);
-	adv7180_write_reg(0x48, 0x00);
-	adv7180_write_reg(0x49, 0x00);
-	adv7180_write_reg(0x4A, 0x00);
-	adv7180_write_reg(0x4B, 0x00);
-	adv7180_write_reg(0x4C, 0x00);
-	adv7180_write_reg(0x4D, 0xEF);
-	adv7180_write_reg(0x4E, 0x08);
-	adv7180_write_reg(0x4F, 0x08);
-	adv7180_write_reg(0x50, 0x08);
-	adv7180_write_reg(0x51, 0x24);
-	adv7180_write_reg(0x52, 0x0B);
-	adv7180_write_reg(0x53, 0x4E);
-	adv7180_write_reg(0x54, 0x80);
-	adv7180_write_reg(0x55, 0x00);
-	adv7180_write_reg(0x56, 0x10);
-	adv7180_write_reg(0x57, 0x00);
-	adv7180_write_reg(0x58, 0x00);
-	adv7180_write_reg(0x59, 0x00);
-	adv7180_write_reg(0x5A, 0x00);
-	adv7180_write_reg(0x5B, 0x00);
-	adv7180_write_reg(0x5C, 0x00);
-	adv7180_write_reg(0x5D, 0x00);
-	adv7180_write_reg(0x5E, 0x00);
-	adv7180_write_reg(0x5F, 0x00);
-	adv7180_write_reg(0x60, 0x00);
-	adv7180_write_reg(0x61, 0x00);
-	adv7180_write_reg(0x62, 0x20);
-	adv7180_write_reg(0x63, 0x00);
-	adv7180_write_reg(0x64, 0x00);
-	adv7180_write_reg(0x65, 0x00);
-	adv7180_write_reg(0x66, 0x00);
-	adv7180_write_reg(0x67, 0x03);
-	adv7180_write_reg(0x68, 0x01);
-	adv7180_write_reg(0x69, 0x00);
-	adv7180_write_reg(0x6A, 0x00);
-	adv7180_write_reg(0x6B, 0xC0);
-	adv7180_write_reg(0x6C, 0x00);
-	adv7180_write_reg(0x6D, 0x00);
-	adv7180_write_reg(0x6E, 0x00);
-	adv7180_write_reg(0x6F, 0x00);
-	adv7180_write_reg(0x70, 0x00);
-	adv7180_write_reg(0x71, 0x00);
-	adv7180_write_reg(0x72, 0x00);
-	adv7180_write_reg(0x73, 0x10);
-	adv7180_write_reg(0x74, 0x04);
-	adv7180_write_reg(0x75, 0x01);
-	adv7180_write_reg(0x76, 0x00);
-	adv7180_write_reg(0x77, 0x3F);
-	adv7180_write_reg(0x78, 0xFF);
-	adv7180_write_reg(0x79, 0xFF);
-	adv7180_write_reg(0x7A, 0xFF);
-	adv7180_write_reg(0x7B, 0x1E);
-	adv7180_write_reg(0x7C, 0xC0);
-	adv7180_write_reg(0x7D, 0x00);
-	adv7180_write_reg(0x7E, 0x00);
-	adv7180_write_reg(0x7F, 0x00);
-	adv7180_write_reg(0x80, 0x00);
-	adv7180_write_reg(0x81, 0xC0);
-	adv7180_write_reg(0x82, 0x04);
-	adv7180_write_reg(0x83, 0x00);
-	adv7180_write_reg(0x84, 0x0C);
-	adv7180_write_reg(0x85, 0x02);
-	adv7180_write_reg(0x86, 0x03);
-	adv7180_write_reg(0x87, 0x63);
-	adv7180_write_reg(0x88, 0x5A);
-	adv7180_write_reg(0x89, 0x08);
-	adv7180_write_reg(0x8A, 0x10);
-	adv7180_write_reg(0x8B, 0x00);
-	adv7180_write_reg(0x8C, 0x40);
-	adv7180_write_reg(0x8D, 0x00);
-	adv7180_write_reg(0x8E, 0x40);
-	adv7180_write_reg(0x8F, 0x00);
-	adv7180_write_reg(0x90, 0x00);
-	adv7180_write_reg(0x91, 0x50);
-	adv7180_write_reg(0x92, 0x00);
-	adv7180_write_reg(0x93, 0x00);
-	adv7180_write_reg(0x94, 0x00);
-	adv7180_write_reg(0x95, 0x00);
-	adv7180_write_reg(0x96, 0x00);
-	adv7180_write_reg(0x97, 0xF0);
-	adv7180_write_reg(0x98, 0x00);
-	adv7180_write_reg(0x99, 0x00);
-	adv7180_write_reg(0x9A, 0x00);
-	adv7180_write_reg(0x9B, 0x00);
-	adv7180_write_reg(0x9C, 0x00);
-	adv7180_write_reg(0x9D, 0x00);
-	adv7180_write_reg(0x9E, 0x00);
-	adv7180_write_reg(0x9F, 0x00);
-	adv7180_write_reg(0xA0, 0x00);
-	adv7180_write_reg(0xA1, 0x00);
-	adv7180_write_reg(0xA2, 0x00);
-	adv7180_write_reg(0xA3, 0x00);
-	adv7180_write_reg(0xA4, 0x00);
-	adv7180_write_reg(0xA5, 0x00);
-	adv7180_write_reg(0xA6, 0x00);
-	adv7180_write_reg(0xA7, 0x00);
-	adv7180_write_reg(0xA8, 0x00);
-	adv7180_write_reg(0xA9, 0x00);
-	adv7180_write_reg(0xAA, 0x00);
-	adv7180_write_reg(0xAB, 0x00);
-	adv7180_write_reg(0xAC, 0x00);
-	adv7180_write_reg(0xAD, 0x00);
-	adv7180_write_reg(0xAE, 0x60);
-	adv7180_write_reg(0xAF, 0x00);
-	adv7180_write_reg(0xB0, 0x00);
-	adv7180_write_reg(0xB1, 0x60);
-	adv7180_write_reg(0xB2, 0x1C);
-	adv7180_write_reg(0xB3, 0x54);
-	adv7180_write_reg(0xB4, 0x00);
-	adv7180_write_reg(0xB5, 0x00);
-	adv7180_write_reg(0xB6, 0x00);
-	adv7180_write_reg(0xB7, 0x13);
-	adv7180_write_reg(0xB8, 0x03);
-	adv7180_write_reg(0xB9, 0x33);
-	adv7180_write_reg(0xBF, 0x02);
-	adv7180_write_reg(0xC0, 0x00);
-	adv7180_write_reg(0xC1, 0x00);
-	adv7180_write_reg(0xC2, 0x00);
-	adv7180_write_reg(0xC3, 0x00);
-	adv7180_write_reg(0xC4, 0x00);
-	adv7180_write_reg(0xC5, 0x81);
-	adv7180_write_reg(0xC6, 0x00);
-	adv7180_write_reg(0xC7, 0x00);
-	adv7180_write_reg(0xC8, 0x00);
-	adv7180_write_reg(0xC9, 0x04);
-	adv7180_write_reg(0xCC, 0x69);
-	adv7180_write_reg(0xCD, 0x00);
-	adv7180_write_reg(0xCE, 0x01);
-	adv7180_write_reg(0xCF, 0xB4);
-	adv7180_write_reg(0xD0, 0x00);
-	adv7180_write_reg(0xD1, 0x10);
-	adv7180_write_reg(0xD2, 0xFF);
-	adv7180_write_reg(0xD3, 0xFF);
-	adv7180_write_reg(0xD4, 0x7F);
-	adv7180_write_reg(0xD5, 0x7F);
-	adv7180_write_reg(0xD6, 0x3E);
-	adv7180_write_reg(0xD7, 0x08);
-	adv7180_write_reg(0xD8, 0x3C);
-	adv7180_write_reg(0xD9, 0x08);
-	adv7180_write_reg(0xDA, 0x3C);
-	adv7180_write_reg(0xDB, 0x9B);
-	adv7180_write_reg(0xDC, 0xAC);
-	adv7180_write_reg(0xDD, 0x4C);
-	adv7180_write_reg(0xDE, 0x00);
-	adv7180_write_reg(0xDF, 0x00);
-	adv7180_write_reg(0xE0, 0x14);
-	adv7180_write_reg(0xE1, 0x80);
-	adv7180_write_reg(0xE2, 0x80);
-	adv7180_write_reg(0xE3, 0x80);
-	adv7180_write_reg(0xE4, 0x80);
-	adv7180_write_reg(0xE5, 0x25);
-	adv7180_write_reg(0xE6, 0x44);
-	adv7180_write_reg(0xE7, 0x63);
-	adv7180_write_reg(0xE8, 0x65);
-	adv7180_write_reg(0xE9, 0x14);
-	adv7180_write_reg(0xEA, 0x63);
-	adv7180_write_reg(0xEB, 0x55);
-	adv7180_write_reg(0xEC, 0x55);
-	adv7180_write_reg(0xEE, 0x00);
-	adv7180_write_reg(0xEF, 0x4A);
-	adv7180_write_reg(0xF0, 0x44);
-	adv7180_write_reg(0xF1, 0x0C);
-	adv7180_write_reg(0xF2, 0x32);
-	adv7180_write_reg(0xF3, 0x00);
-	adv7180_write_reg(0xF4, 0x3F);
-	adv7180_write_reg(0xF5, 0xE0);
-	adv7180_write_reg(0xF6, 0x69);
-	adv7180_write_reg(0xF7, 0x10);
-	adv7180_write_reg(0xF8, 0x00);
-	adv7180_write_reg(0xF9, 0x03);
-	adv7180_write_reg(0xFA, 0xFA);
-	adv7180_write_reg(0xFB, 0x40);
+	adv7180_write_reg(0x0F, 0x40); /* TRAQ */
+	adv7180_write_reg(0x01, 0x80); /* disable Hsync pll, Vsync processor */
+	adv7180_write_reg(0x19, 0xB1); /* Mv robustnesss bit */
+	adv7180_write_reg(0x2C, 0x12); /* Use sync based AGC */
+	adv7180_write_reg(0x31, 0x02); /* Clears NEWAV_MODE  AV_MODE,SAV/EAV to suit ADV encoders */
+	adv7180_write_reg(0x37, 0x81); /* HS polarity */
+	adv7180_write_reg(0x51, 0x89); /* FSCLE enabled, CIL,COL */
+	adv7180_write_reg(0x3A, 0x16); /* Power down U and V ADC's */
+	adv7180_write_reg(0x3D, 0xA2); /* MWE Enable Manual Window, Colour Kill Threshold to 2 */
+	adv7180_write_reg(0x3E, 0x6A); /* BLM optimisation */
+	adv7180_write_reg(0x3F, 0xA0); /* BGB */
+	adv7180_write_reg(0x51, 0x9B); /* ADI Recommended Write */
+	adv7180_write_reg(0x0E, 0x85); /* ADI Recommended Write */
+	adv7180_write_reg(0xB6, 0x0C); /* manual enables for agc & clamp loop speeds */
+	adv7180_write_reg(0xBE, 0xC0); /* speed of digital agc loop */
+	adv7180_write_reg(0xC0, 0xC0); /* speed of digital clamp loop */
+	adv7180_write_reg(0xD1, 0xB9); /* Disable always flip field ID bit, Disable VCR FIELD filtering for switching application */
+	adv7180_write_reg(0xD6, 0x6D); /* ADI Recommended Write */
+	adv7180_write_reg(0xD9, 0x44); /* Toggle LSF set to zero */
+	adv7180_write_reg(0x0E, 0x80); /* ADI Recommended Write */
+	adv7180_write_reg(0x55, 0x81); /* ADI Recommended Write */
+	adv7180_write_reg(0x0E, 0x00); /* ADI Recommended Write */
+	adv7180_write_reg(0xF4, 0x3F); /* High drive strength (4×) */
 }
 
 /*! ADV7180 I2C attach function.
@@ -1160,6 +971,7 @@
 {
 	int rev_id;
 	int ret = 0;
+	u32 cam_std = 0; /* PAL */
 	u32 cvbs = true;
 	struct pinctrl *pinctrl;
 	struct device *dev = &client->dev;
@@ -1175,15 +987,13 @@
 
 	/* request power down pin */
 	pwn_gpio = of_get_named_gpio(dev->of_node, "pwn-gpios", 0);
-	if (!gpio_is_valid(pwn_gpio)) {
-		dev_err(dev, "no sensor pwdn pin available\n");
-		return -ENODEV;
-	}
-	ret = devm_gpio_request_one(dev, pwn_gpio, GPIOF_OUT_INIT_HIGH,
+	if (gpio_is_valid(pwn_gpio)) {
+		ret = devm_gpio_request_one(dev, pwn_gpio, GPIOF_OUT_INIT_HIGH,
 					"adv7180_pwdn");
-	if (ret < 0) {
-		dev_err(dev, "no power pin available!\n");
-		return ret;
+		if (ret < 0) {
+			dev_err(dev, "request power down pin\n");
+			return ret;
+		}
 	}
 
 	adv7180_regulator_enable(dev);
@@ -1194,11 +1004,36 @@
 
 	/* Set initial values for the sensor struct. */
 	memset(&adv7180_data, 0, sizeof(adv7180_data));
+
+	ret = of_property_read_u32(dev->of_node, "cam_std", &cam_std);
+	if (ret) {
+		dev_err(dev, "cam_std setting is not found, cam_std = 0 (PAL)\n");
+		cam_std = 0;
+	}
+
+	switch (cam_std) {
+	case 1:
+		/* NTSC J */
+		adv7180_data.std_id = V4L2_STD_NTSC;
+		adv7180_data.cam_std = 0x40;
+		video_idx = ADV7180_NTSC;
+		break;
+	case 2:
+		/* NTSC M */
+		adv7180_data.std_id = V4L2_STD_NTSC;
+		adv7180_data.cam_std = 0x50;
+		video_idx = ADV7180_NTSC;
+		break;
+	default:
+		/* PAL */
+		adv7180_data.std_id = V4L2_STD_PAL;
+		adv7180_data.cam_std = 0x80;
+		video_idx = ADV7180_PAL;
+	}
+
 	adv7180_data.sen.i2c_client = client;
 	adv7180_data.sen.streamcap.timeperframe.denominator = 30;
 	adv7180_data.sen.streamcap.timeperframe.numerator = 1;
-	adv7180_data.std_id = V4L2_STD_ALL;
-	video_idx = ADV7180_NOT_LOCKED;
 	adv7180_data.sen.pix.width = video_fmts[video_idx].raw_width;
 	adv7180_data.sen.pix.height = video_fmts[video_idx].raw_height;
 	adv7180_data.sen.pix.pixelformat = V4L2_PIX_FMT_UYVY;  /* YUV422 */
diff -urN fsl/drivers/media/platform/mxc/capture/Makefile sk/drivers/media/platform/mxc/capture/Makefile
--- fsl/drivers/media/platform/mxc/capture/Makefile	2014-09-18 21:48:51.000000000 +0400
+++ sk/drivers/media/platform/mxc/capture/Makefile	2014-10-24 21:56:06.000000000 +0400
@@ -1,6 +1,7 @@
 obj-$(CONFIG_VIDEO_MXC_CSI_CAMERA)	+= fsl_csi.o csi_v4l2_capture.o
 
 ifeq ($(CONFIG_VIDEO_MXC_IPU_CAMERA),y)
+#	CFLAGS_mxc_v4l2_capture.o := -DDEBUG
 	obj-$(CONFIG_VIDEO_MXC_CAPTURE) += mxc_v4l2_capture.o
 	obj-$(CONFIG_MXC_IPU_PRP_VF_SDC) += ipu_prp_vf_sdc.o ipu_prp_vf_sdc_bg.o
 	obj-$(CONFIG_MXC_IPU_DEVICE_QUEUE_SDC) += ipu_fg_overlay_sdc.o ipu_bg_overlay_sdc.o
diff -urN fsl/drivers/media/platform/mxc/capture/mxc_v4l2_capture.c sk/drivers/media/platform/mxc/capture/mxc_v4l2_capture.c
--- fsl/drivers/media/platform/mxc/capture/mxc_v4l2_capture.c	2014-09-18 21:48:51.000000000 +0400
+++ sk/drivers/media/platform/mxc/capture/mxc_v4l2_capture.c	2014-10-24 21:56:06.000000000 +0400
@@ -44,6 +44,7 @@
 #include "ipu_prp_sw.h"
 
 #define init_MUTEX(sem)         sema_init(sem, 1)
+#define ADV7180_NUM_AINS		6
 
 static struct platform_device_id imx_v4l2_devtype[] = {
 	{
@@ -124,7 +125,7 @@
 	 },
 };
 
-static struct v4l2_input mxc_capture_inputs[MXC_V4L2_CAPTURE_NUM_INPUTS] = {
+static struct v4l2_input mxc_capture_inputs[MXC_V4L2_CAPTURE_NUM_INPUTS + 6] = {
 	{
 	 .index = 0,
 	 .name = "CSI IC MEM",
@@ -424,6 +425,13 @@
 			"queued yet\n");
 		return -EINVAL;
 	}
+
+	if (cam->ain != 0) {
+		cam->capture_pid = current->pid;
+		cam->capture_on = true;
+		return 0;
+	}
+	
 	if (cam->enc_update_eba &&
 		cam->ready_q.prev == cam->ready_q.next) {
 		pr_err("ERROR: v4l2 capture: mxc_streamon buffer need "
@@ -453,14 +461,18 @@
 		frame->ipu_buf_num = cam->ping_pong_csi;
 		err = cam->enc_update_eba(cam->ipu, frame->buffer.m.offset,
 					  &cam->ping_pong_csi);
-
-		frame =
-		    list_entry(cam->ready_q.next, struct mxc_v4l_frame, queue);
-		list_del(cam->ready_q.next);
-		list_add_tail(&frame->queue, &cam->working_q);
-		frame->ipu_buf_num = cam->ping_pong_csi;
-		err |= cam->enc_update_eba(cam->ipu, frame->buffer.m.offset,
+		if (cam->ain_num == 1) {
+			frame =
+				list_entry(cam->ready_q.next, struct mxc_v4l_frame, queue);
+			list_del(cam->ready_q.next);
+			list_add_tail(&frame->queue, &cam->working_q);
+			frame->ipu_buf_num = cam->ping_pong_csi;
+			err |= cam->enc_update_eba(cam->ipu, frame->buffer.m.offset,
 					   &cam->ping_pong_csi);
+		} else 
+			cam->enc_update_eba(cam->ipu,
+					cam->dummy_frame.buffer.m.offset,
+					&cam->ping_pong_csi);
 		spin_unlock_irqrestore(&cam->queue_int_lock, lock_flags);
 	} else {
 		spin_unlock_irqrestore(&cam->queue_int_lock, lock_flags);
@@ -503,7 +515,8 @@
 	 * 3. disable idmac
 	 * 4. disable smfc (CSI--MEM channel)
 	 */
-	if (mxc_capture_inputs[cam->current_input].name != NULL) {
+	if ((mxc_capture_inputs[cam->current_input].name != NULL) && 
+		(cam->ain == 0)) {
 		if (cam->enc_disable_csi) {
 			err = cam->enc_disable_csi(cam);
 			if (err != 0)
@@ -1514,13 +1527,13 @@
 	struct mxc_v4l_frame *frame;
 	unsigned long lock_flags;
 
-	pr_debug("In MVC:mxc_v4l_dqueue\n");
+	pr_debug("In MVC:mxc_v4l_dqueue cam = 0x%x\n", (u32)cam);
 
 	if (!wait_event_interruptible_timeout(cam->enc_queue,
 					      cam->enc_counter != 0, 10 * HZ)) {
 		pr_err("ERROR: v4l2 capture: mxc_v4l_dqueue timeout "
-			"enc_counter %x\n",
-		       cam->enc_counter);
+			"enc_counter %x  cam = 0x%x\n",
+		       cam->enc_counter, (u32)cam);
 		return -ETIME;
 	} else if (signal_pending(current)) {
 		pr_err("ERROR: v4l2 capture: mxc_v4l_dqueue() "
@@ -1583,7 +1596,7 @@
 	struct sensor_data *sensor;
 
 	pr_debug("\nIn MVC: mxc_v4l_open\n");
-	pr_debug("   device name is %s\n", dev->name);
+	pr_debug("   device name is %s cam = 0x%x\n", dev->name, (u32)cam);
 
 	if (!cam) {
 		pr_err("ERROR: v4l2 capture: Internal error, "
@@ -1612,8 +1625,8 @@
 		wait_event_interruptible(cam->power_queue,
 					 cam->low_power == false);
 
-		if (strcmp(mxc_capture_inputs[cam->current_input].name,
-			   "CSI MEM") == 0) {
+		if ((strcmp(mxc_capture_inputs[cam->current_input].name,
+			   "CSI MEM") == 0) && (cam->ain == 0)) {
 #if defined(CONFIG_MXC_IPU_CSI_ENC) || defined(CONFIG_MXC_IPU_CSI_ENC_MODULE)
 			err = csi_enc_select(cam);
 #endif
@@ -1625,6 +1638,7 @@
 		}
 
 		cam->enc_counter = 0;
+		cam->ain_active = 0;
 		INIT_LIST_HEAD(&cam->ready_q);
 		INIT_LIST_HEAD(&cam->working_q);
 		INIT_LIST_HEAD(&cam->done_q);
@@ -1695,20 +1709,23 @@
 		csi_param.data_fmt = cam_fmt.fmt.pix.pixelformat;
 		pr_debug("On Open: Input to ipu size is %d x %d\n",
 				cam_fmt.fmt.pix.width, cam_fmt.fmt.pix.height);
-		ipu_csi_set_window_size(cam->ipu, cam->crop_current.width,
+
+		if (cam->ain == 0) {
+			ipu_csi_set_window_size(cam->ipu, cam->crop_current.width,
 					cam->crop_current.height,
 					cam->csi);
-		ipu_csi_set_window_pos(cam->ipu, cam->crop_current.left,
+			ipu_csi_set_window_pos(cam->ipu, cam->crop_current.left,
 					cam->crop_current.top,
 					cam->csi);
-		ipu_csi_init_interface(cam->ipu, cam->crop_bounds.width,
+			ipu_csi_init_interface(cam->ipu, cam->crop_bounds.width,
 					cam->crop_bounds.height,
 					cam_fmt.fmt.pix.pixelformat,
 					csi_param);
-		clk_prepare_enable(sensor->sensor_clk);
-		vidioc_int_s_power(cam->sensor, 1);
-		vidioc_int_init(cam->sensor);
-		vidioc_int_dev_init(cam->sensor);
+			clk_prepare_enable(sensor->sensor_clk);
+			vidioc_int_s_power(cam->sensor, 1);
+			vidioc_int_init(cam->sensor);
+			vidioc_int_dev_init(cam->sensor);
+		}
 	}
 
 	file->private_data = dev;
@@ -1753,7 +1770,7 @@
 	down(&cam->busy_lock);
 
 	/* for the case somebody hit the ctrl C */
-	if (cam->overlay_pid == current->pid && cam->overlay_on) {
+	if ((cam->overlay_pid == current->pid && cam->overlay_on) && (cam->ain == 0)) {
 		err = stop_preview(cam);
 		cam->overlay_on = false;
 	}
@@ -1763,14 +1780,16 @@
 	}
 
 	if (--cam->open_count == 0) {
-		vidioc_int_s_power(cam->sensor, 0);
-		clk_disable_unprepare(sensor->sensor_clk);
+		if (cam->ain == 0) {
+			vidioc_int_s_power(cam->sensor, 0);
+			clk_disable_unprepare(sensor->sensor_clk);
+		}
 		wait_event_interruptible(cam->power_queue,
 					 cam->low_power == false);
 		pr_debug("mxc_v4l_close: release resource\n");
 
-		if (strcmp(mxc_capture_inputs[cam->current_input].name,
-			   "CSI MEM") == 0) {
+		if ((strcmp(mxc_capture_inputs[cam->current_input].name,
+			   "CSI MEM") == 0)  && (cam->ain == 0)) {
 #if defined(CONFIG_MXC_IPU_CSI_ENC) || defined(CONFIG_MXC_IPU_CSI_ENC_MODULE)
 			err |= csi_enc_deselect(cam);
 #endif
@@ -2169,12 +2188,14 @@
 		pr_debug("   Cropping Input to ipu size %d x %d\n",
 				cam->crop_current.width,
 				cam->crop_current.height);
-		ipu_csi_set_window_size(cam->ipu, cam->crop_current.width,
+		if (cam->ain == 0) {
+			ipu_csi_set_window_size(cam->ipu, cam->crop_current.width,
 					cam->crop_current.height,
 					cam->csi);
-		ipu_csi_set_window_pos(cam->ipu, cam->crop_current.left,
+			ipu_csi_set_window_pos(cam->ipu, cam->crop_current.left,
 				       cam->crop_current.top,
 				       cam->csi);
+		}
 		break;
 	}
 
@@ -2233,7 +2254,7 @@
 		struct v4l2_streamparm *parm = arg;
 		pr_debug("   case VIDIOC_S_PARM\n");
 		if (cam->sensor)
-			retval = mxc_v4l2_s_param(cam, parm);
+			retval = (cam->ain == 0) ? mxc_v4l2_s_param(cam, parm) : 0;
 		else {
 			pr_err("ERROR: v4l2 capture: slave not found!\n");
 			retval = -ENODEV;
@@ -2301,11 +2322,14 @@
 	case VIDIOC_ENUMINPUT: {
 		struct v4l2_input *input = arg;
 		pr_debug("   case VIDIOC_ENUMINPUT\n");
-		if (input->index >= MXC_V4L2_CAPTURE_NUM_INPUTS) {
+		if (input->index >= (MXC_V4L2_CAPTURE_NUM_INPUTS + ADV7180_NUM_AINS)) {
 			retval = -EINVAL;
 			break;
 		}
-		*input = mxc_capture_inputs[input->index];
+		if (input->index >= MXC_V4L2_CAPTURE_NUM_INPUTS)
+			*input = mxc_capture_inputs[cam->current_input];
+		else
+			*input = mxc_capture_inputs[input->index];
 		break;
 	}
 
@@ -2320,7 +2344,16 @@
 		int *index = arg;
 		pr_debug("   case VIDIOC_S_INPUT\n");
 		if (*index >= MXC_V4L2_CAPTURE_NUM_INPUTS) {
-			retval = -EINVAL;
+			if (*index < (MXC_V4L2_CAPTURE_NUM_INPUTS + ADV7180_NUM_AINS)
+					&& (cam->ain_num == 1)) {
+				unsigned long flags;
+				
+				spin_lock_irqsave(&cam->dqueue_int_lock, flags);
+				cam->ain_active = *index - MXC_V4L2_CAPTURE_NUM_INPUTS;
+				cam->ain_switch_req = 1;
+				spin_unlock_irqrestore(&cam->dqueue_int_lock, flags);
+			} else 
+				retval = -EINVAL;
 			break;
 		}
 
@@ -2336,7 +2369,8 @@
 							V4L2_IN_ST_NO_POWER;
 		}
 
-		if (strcmp(mxc_capture_inputs[*index].name, "CSI MEM") == 0) {
+		if ((strcmp(mxc_capture_inputs[*index].name, "CSI MEM") == 0) &&
+			(cam->ain == 0)) {
 #if defined(CONFIG_MXC_IPU_CSI_ENC) || defined(CONFIG_MXC_IPU_CSI_ENC_MODULE)
 			retval = csi_enc_select(cam);
 			if (retval)
@@ -2474,7 +2508,7 @@
 	wait_queue_head_t *queue = NULL;
 	int res = POLLIN | POLLRDNORM;
 
-	pr_debug("In MVC:mxc_poll\n");
+	pr_debug("In MVC:mxc_poll cam = 0x%x\n", (u32)cam);
 
 	if (down_interruptible(&cam->busy_lock))
 		return -EINTR;
@@ -2536,6 +2570,13 @@
 
 	spin_lock(&cam->queue_int_lock);
 	spin_lock(&cam->dqueue_int_lock);
+
+	if (cam->ain_switch_req) {
+		quick_disable_csi(cam->ipu, cam->csi);
+		schedule_work(&cam->ain_switch_work);
+		cam->ain_switch_req = 0;
+	}
+
 	if (!list_empty(&cam->working_q)) {
 		do_gettimeofday(&cur_time);
 
@@ -2543,8 +2584,10 @@
 					struct mxc_v4l_frame,
 					queue);
 
-		if (done_frame->ipu_buf_num != cam->local_buf_num)
+		if (done_frame->ipu_buf_num != cam->local_buf_num) {
+			printk("SK: ipu != local\n");
 			goto next;
+		}
 
 		/*
 		 * Set the current time to done frame buffer's
@@ -2597,6 +2640,104 @@
 	return;
 }
 
+static void ain_switch(struct work_struct *work)
+{
+	cam_data *cam = container_of(work, cam_data, ain_switch_work);
+	struct v4l2_routing route;
+
+	route.input = cam->ain_active;
+	vidioc_int_s_video_routing(cam->sensor, &route);
+	quick_enable_csi(cam->ipu, cam->csi);
+}
+
+static void camera_callback_multi_ain(u32 mask, void *dev)
+{
+	struct mxc_v4l_frame *done_frame;
+	struct mxc_v4l_frame *ready_frame;
+	struct timeval cur_time;
+	cam_data *cam;
+
+	cam_data *cam_pool = (cam_data *) dev;
+	if (cam_pool == NULL)
+		return;
+
+	cam = &cam_pool[cam_pool->ain_active];
+
+	pr_debug("In MVC:camera_callback cam = 0x%x\n", (u32)cam);
+
+	if (cam_pool->ping_pong_csi == 0) {
+		quick_disable_csi(cam_pool->ipu, cam_pool->csi);
+		
+		if (!list_empty(&cam->working_q)) {
+			do_gettimeofday(&cur_time);
+
+			done_frame = list_entry(cam->working_q.next,
+					struct mxc_v4l_frame,
+					queue);
+			/*
+			 * Set the current time to done frame buffer's
+			 * timestamp. Users can use this information to judge
+			 * the frame's usage.
+			 */
+			done_frame->buffer.timestamp = cur_time;
+
+			if (done_frame->buffer.flags & V4L2_BUF_FLAG_QUEUED) {
+				done_frame->buffer.flags |= V4L2_BUF_FLAG_DONE;
+				done_frame->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;
+
+				spin_lock(&cam->queue_int_lock);
+				spin_lock(&cam->dqueue_int_lock);
+
+				/* Added to the done queue */
+				list_del(cam->working_q.next);
+				list_add_tail(&done_frame->queue, &cam->done_q);
+
+				spin_unlock(&cam->dqueue_int_lock);
+				spin_unlock(&cam->queue_int_lock);
+
+				/* Wake up the queue */
+				cam->enc_counter++;
+				wake_up_interruptible(&cam->enc_queue);
+			} else
+				pr_err("ERROR: v4l2 capture: camera_callback: "
+						"buffer not queued\n");
+		}
+
+		/* next ain */		
+		if (++cam_pool->ain_active == cam_pool->ain_num)
+				cam_pool->ain_active = 0;
+		cam = &cam_pool[cam_pool->ain_active];		
+
+		spin_lock(&cam->queue_int_lock);
+		spin_lock(&cam->dqueue_int_lock);
+
+		if (!list_empty(&cam->ready_q)) {
+				ready_frame = list_entry(cam->ready_q.next,
+				struct mxc_v4l_frame,
+				queue);
+			if (cam_pool->enc_update_eba(cam_pool->ipu,
+					ready_frame->buffer.m.offset,
+					&cam_pool->ping_pong_csi) == 0) {
+				list_del(cam->ready_q.next);
+				list_add_tail(&ready_frame->queue, &cam->working_q);
+			}
+		} else {
+			cam_pool->enc_update_eba(cam_pool->ipu,
+					cam_pool->dummy_frame.buffer.m.offset,
+					&cam_pool->ping_pong_csi);
+		}
+
+		spin_unlock(&cam->dqueue_int_lock);
+		spin_unlock(&cam->queue_int_lock);
+
+		schedule_work(&cam_pool->ain_switch_work);
+	} else {
+		cam_pool->enc_update_eba(cam_pool->ipu,
+				cam_pool->dummy_frame.buffer.m.offset,
+				&cam_pool->ping_pong_csi);
+	}
+}
+
 /*!
  * initialize cam_data structure
  *
@@ -2604,12 +2745,13 @@
  *
  * @return status  0 Success
  */
-static int init_camera_struct(cam_data *cam, struct platform_device *pdev)
+static cam_data * init_camera_struct(struct platform_device *pdev)
 {
 	const struct of_device_id *of_id =
 			of_match_device(mxc_v4l2_dt_ids, &pdev->dev);
 	struct device_node *np = pdev->dev.of_node;
-	int ipu_id, csi_id, mclk_source;
+	int ipu_id, csi_id, mclk_source, ain_num, ain;
+	cam_data *cam_pool = NULL;
 	int ret = 0;
 
 	pr_debug("In MVC: init_camera_struct\n");
@@ -2617,23 +2759,41 @@
 	ret = of_property_read_u32(np, "ipu_id", &ipu_id);
 	if (ret) {
 		dev_err(&pdev->dev, "ipu_id missing or invalid\n");
-		return ret;
+		return cam_pool;
 	}
 
 	ret = of_property_read_u32(np, "csi_id", &csi_id);
 	if (ret) {
 		dev_err(&pdev->dev, "csi_id missing or invalid\n");
-		return ret;
+		return cam_pool;
 	}
 
 	ret = of_property_read_u32(np, "mclk_source", &mclk_source);
 	if (ret) {
 		dev_err(&pdev->dev, "sensor mclk missing or invalid\n");
-		return ret;
+		return cam_pool;
+	}
+
+	ret = of_property_read_u32(np, "ain_num", &ain_num);
+	if (ret) {
+		dev_info(&pdev->dev, "ain_num missing, ain_num = 1\n");
+		ain_num = 1;
+	}
+
+	if (ain_num < 1 || ain_num > 6) {
+		dev_info(&pdev->dev, "wrong value ain_num = %d, ain_num = 1\n", ain_num);
+		ain_num = 1;
+	}
+
+	/* Create cam and initialize it. */
+	cam_pool = kmalloc(ain_num * sizeof(cam_data), GFP_KERNEL);
+	if (cam_pool == NULL) {
+		pr_err("ERROR: v4l2 capture: failed to register camera\n");
+		return cam_pool;
 	}
 
 	/* Default everything to 0 */
-	memset(cam, 0, sizeof(cam_data));
+	memset(cam_pool, 0, ain_num * sizeof(cam_data));
 
 	/* get devtype to distinguish if the cpu is imx5 or imx6
 	 * IMX5_V4L2 specify the cpu is imx5
@@ -2641,85 +2801,99 @@
 	 */
 	if (of_id)
 		pdev->id_entry = of_id->data;
-	cam->devtype = pdev->id_entry->driver_data;
-
-	cam->ipu = ipu_get_soc(ipu_id);
-	if (cam->ipu == NULL) {
-		pr_err("ERROR: v4l2 capture: failed to get ipu\n");
-		return -EINVAL;
-	} else if (cam->ipu == ERR_PTR(-ENODEV)) {
-		pr_err("ERROR: v4l2 capture: get invalid ipu\n");
-		return -ENODEV;
-	}
-
-	init_MUTEX(&cam->param_lock);
-	init_MUTEX(&cam->busy_lock);
-
-	cam->video_dev = video_device_alloc();
-	if (cam->video_dev == NULL)
-		return -ENODEV;
 
-	*(cam->video_dev) = mxc_v4l_template;
+	for (ain = 0; ain < ain_num; ain++) {
+		cam_data *cam = &cam_pool[ain];
 
-	video_set_drvdata(cam->video_dev, cam);
-	dev_set_drvdata(&pdev->dev, (void *)cam);
-	cam->video_dev->minor = -1;
+		cam->ain_num = ain_num;
+		cam->ain = ain;
 
-	init_waitqueue_head(&cam->enc_queue);
-	init_waitqueue_head(&cam->still_queue);
-
-	/* setup cropping */
-	cam->crop_bounds.left = 0;
-	cam->crop_bounds.width = 640;
-	cam->crop_bounds.top = 0;
-	cam->crop_bounds.height = 480;
-	cam->crop_current = cam->crop_defrect = cam->crop_bounds;
-	ipu_csi_set_window_size(cam->ipu, cam->crop_current.width,
-				cam->crop_current.height, cam->csi);
-	ipu_csi_set_window_pos(cam->ipu, cam->crop_current.left,
-				cam->crop_current.top, cam->csi);
-	cam->streamparm.parm.capture.capturemode = 0;
-
-	cam->standard.index = 0;
-	cam->standard.id = V4L2_STD_UNKNOWN;
-	cam->standard.frameperiod.denominator = 30;
-	cam->standard.frameperiod.numerator = 1;
-	cam->standard.framelines = 480;
-	cam->standard_autodetect = true;
-	cam->streamparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	cam->streamparm.parm.capture.timeperframe = cam->standard.frameperiod;
-	cam->streamparm.parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
-	cam->overlay_on = false;
-	cam->capture_on = false;
-	cam->v4l2_fb.flags = V4L2_FBUF_FLAG_OVERLAY;
+		pr_debug("   SK: init_camera_struct cam=0x%x ain=%d\n", (u32)cam, cam->ain);
+		
+		cam->devtype = pdev->id_entry->driver_data;
+
+		cam->ipu = ipu_get_soc(ipu_id);
+		if (cam->ipu == NULL) {
+			pr_err("ERROR: v4l2 capture: failed to get ipu\n");
+			return NULL;
+		} else if (cam->ipu == ERR_PTR(-ENODEV)) {
+			pr_err("ERROR: v4l2 capture: get invalid ipu\n");
+			return NULL;
+		}
+
+		init_MUTEX(&cam->param_lock);
+		init_MUTEX(&cam->busy_lock);
+
+		cam->video_dev = video_device_alloc();
+		if (cam->video_dev == NULL)
+			return NULL;
+
+		*(cam->video_dev) = mxc_v4l_template;
+
+		video_set_drvdata(cam->video_dev, cam);
+		cam->video_dev->minor = -1;
+
+		init_waitqueue_head(&cam->enc_queue);
+		init_waitqueue_head(&cam->still_queue);
+
+		/* setup cropping */
+		cam->crop_bounds.left = 0;
+		cam->crop_bounds.width = 640;
+		cam->crop_bounds.top = 0;
+		cam->crop_bounds.height = 480;
+		cam->crop_current = cam->crop_defrect = cam->crop_bounds;
+
+		cam->streamparm.parm.capture.capturemode = 0;
+
+		cam->standard.index = 0;
+		cam->standard.id = V4L2_STD_UNKNOWN;
+		cam->standard.frameperiod.denominator = 30;
+		cam->standard.frameperiod.numerator = 1;
+		cam->standard.framelines = 480;
+		cam->standard_autodetect = true;
+		cam->streamparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		cam->streamparm.parm.capture.timeperframe = cam->standard.frameperiod;
+		cam->streamparm.parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		cam->overlay_on = false;
+		cam->capture_on = false;
+		cam->v4l2_fb.flags = V4L2_FBUF_FLAG_OVERLAY;
 
-	cam->v2f.fmt.pix.sizeimage = 352 * 288 * 3 / 2;
-	cam->v2f.fmt.pix.bytesperline = 288 * 3 / 2;
-	cam->v2f.fmt.pix.width = 288;
-	cam->v2f.fmt.pix.height = 352;
-	cam->v2f.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;
-	cam->win.w.width = 160;
-	cam->win.w.height = 160;
-	cam->win.w.left = 0;
-	cam->win.w.top = 0;
-
-	cam->ipu_id = ipu_id;
-	cam->csi = csi_id;
-	cam->mclk_source = mclk_source;
-	cam->mclk_on[cam->mclk_source] = false;
-
-	cam->enc_callback = camera_callback;
-	init_waitqueue_head(&cam->power_queue);
-	spin_lock_init(&cam->queue_int_lock);
-	spin_lock_init(&cam->dqueue_int_lock);
-
-	cam->self = kmalloc(sizeof(struct v4l2_int_device), GFP_KERNEL);
-	cam->self->module = THIS_MODULE;
-	sprintf(cam->self->name, "mxc_v4l2_cap%d", cam->csi);
-	cam->self->type = v4l2_int_type_master;
-	cam->self->u.master = &mxc_v4l2_master;
+		cam->v2f.fmt.pix.sizeimage = 352 * 288 * 3 / 2;
+		cam->v2f.fmt.pix.bytesperline = 288 * 3 / 2;
+		cam->v2f.fmt.pix.width = 288;
+		cam->v2f.fmt.pix.height = 352;
+		cam->v2f.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;
+		cam->win.w.width = 160;
+		cam->win.w.height = 160;
+		cam->win.w.left = 0;
+		cam->win.w.top = 0;
+
+		cam->ipu_id = ipu_id;
+		cam->csi = csi_id;
+		cam->mclk_source = mclk_source;
+		cam->mclk_on[cam->mclk_source] = false;
+
+		cam->enc_callback = 
+			(cam->ain_num > 1) ? camera_callback_multi_ain : camera_callback;
+		init_waitqueue_head(&cam->power_queue);
+		spin_lock_init(&cam->queue_int_lock);
+		spin_lock_init(&cam->dqueue_int_lock);
+	}
+
+	cam_pool->self = kmalloc(sizeof(struct v4l2_int_device), GFP_KERNEL);
+	cam_pool->self->module = THIS_MODULE;
+	sprintf(cam_pool->self->name, "mxc_v4l2_cap%d", cam_pool->csi);
+	cam_pool->self->type = v4l2_int_type_master;
+	cam_pool->self->u.master = &mxc_v4l2_master;
+
+	ipu_csi_set_window_size(cam_pool->ipu, cam_pool->crop_current.width,
+				cam_pool->crop_current.height, cam_pool->csi);
+	ipu_csi_set_window_pos(cam_pool->ipu, cam_pool->crop_current.left,
+				cam_pool->crop_current.top, cam_pool->csi);
+				
+	dev_set_drvdata(&pdev->dev, (void *)cam_pool);
 
-	return 0;
+	return cam_pool;
 }
 
 static ssize_t show_streaming(struct device *dev,
@@ -2771,45 +2945,51 @@
  */
 static int mxc_v4l2_probe(struct platform_device *pdev)
 {
+	int ain;
 	/* Create cam and initialize it. */
-	cam_data *cam = kmalloc(sizeof(cam_data), GFP_KERNEL);
-	if (cam == NULL) {
+	cam_data *cam_pool = init_camera_struct(pdev);
+	if (cam_pool == NULL) {
 		pr_err("ERROR: v4l2 capture: failed to register camera\n");
 		return -1;
 	}
-
-	init_camera_struct(cam, pdev);
+	
 	pdev->dev.release = camera_platform_release;
 
-	/* Set up the v4l2 device and register it*/
-	cam->self->priv = cam;
-	v4l2_int_device_register(cam->self);
-
-	/* register v4l video device */
-	if (video_register_device(cam->video_dev, VFL_TYPE_GRABBER, video_nr)
-	    == -1) {
-		kfree(cam);
-		cam = NULL;
-		pr_err("ERROR: v4l2 capture: video_register_device failed\n");
-		return -1;
-	}
-	pr_debug("   Video device registered: %s #%d\n",
-		 cam->video_dev->name, cam->video_dev->minor);
+	for (ain = 0; ain < cam_pool->ain_num; ain++) {
+		cam_data *cam = &cam_pool[ain];
+		
+		if (ain == 0) {
+			/* Set up the v4l2 device and register it*/
+			cam->self->priv = cam;
+			v4l2_int_device_register(cam->self);
+			INIT_WORK(&cam->ain_switch_work, ain_switch);
+		}
+		
+		/* register v4l video device */
+		if (video_register_device(cam->video_dev, VFL_TYPE_GRABBER, video_nr) == -1) {
+			kfree(cam_pool);
+			cam_pool = NULL;
+			pr_err("ERROR: v4l2 capture: video_register_device failed ain=%d\n", ain);
+			return -1;
+		}
+		pr_debug("   Video device registered: ain=%d %s #%d\n",
+			ain, cam->video_dev->name, cam->video_dev->minor);
 
-	if (device_create_file(&cam->video_dev->dev,
-			&dev_attr_fsl_v4l2_capture_property))
-		dev_err(&pdev->dev, "Error on creating sysfs file"
-			" for capture\n");
-
-	if (device_create_file(&cam->video_dev->dev,
-			&dev_attr_fsl_v4l2_overlay_property))
-		dev_err(&pdev->dev, "Error on creating sysfs file"
-			" for overlay\n");
-
-	if (device_create_file(&cam->video_dev->dev,
-			&dev_attr_fsl_csi_property))
-		dev_err(&pdev->dev, "Error on creating sysfs file"
-			" for csi number\n");
+		if (device_create_file(&cam->video_dev->dev,
+				&dev_attr_fsl_v4l2_capture_property))
+			dev_err(&pdev->dev, "Error on creating sysfs file"
+			" for capture ain=%d\n", ain);
+
+		if (device_create_file(&cam->video_dev->dev,
+				&dev_attr_fsl_v4l2_overlay_property))
+			dev_err(&pdev->dev, "Error on creating sysfs file"
+			" for overlay ain=%d\n", ain);
+
+		if (device_create_file(&cam->video_dev->dev,
+				&dev_attr_fsl_csi_property))
+			dev_err(&pdev->dev, "Error on creating sysfs file"
+			" for csi number ain=%d\n", ain);
+	}
 
 	return 0;
 }
@@ -2959,74 +3139,82 @@
  */
 static int mxc_v4l2_master_attach(struct v4l2_int_device *slave)
 {
-	cam_data *cam = slave->u.slave->master->priv;
+	cam_data *cam_pool = slave->u.slave->master->priv;
 	struct v4l2_format cam_fmt;
-	int i;
+	int i, ain;
 	struct sensor_data *sdata = slave->priv;
 
 	pr_debug("In MVC: mxc_v4l2_master_attach\n");
 	pr_debug("   slave.name = %s\n", slave->name);
 	pr_debug("   master.name = %s\n", slave->u.slave->master->name);
 
+	pr_debug("   SK: master_attach cam=0x%x ain=%d\n", (u32)cam_pool, cam_pool->ain);
+
 	if (slave == NULL) {
 		pr_err("ERROR: v4l2 capture: slave parameter not valid.\n");
 		return -1;
 	}
 
-	if (sdata->csi != cam->csi) {
+	if (sdata->csi != cam_pool->csi) {
 		pr_debug("%s: csi doesn't match\n", __func__);
 		return -1;
 	}
 
-	cam->sensor = slave;
-
-	if (cam->sensor_index < MXC_SENSOR_NUM) {
-		cam->all_sensors[cam->sensor_index] = slave;
-		cam->sensor_index++;
+	if (cam_pool->sensor_index < MXC_SENSOR_NUM) {
+		cam_pool->all_sensors[cam_pool->sensor_index] = slave;
+		cam_pool->sensor_index++;
 	} else {
 		pr_err("ERROR: v4l2 capture: slave number exceeds the maximum.\n");
 		return -1;
 	}
 
-	for (i = 0; i < cam->sensor_index; i++) {
-		vidioc_int_dev_exit(cam->all_sensors[i]);
-		vidioc_int_s_power(cam->all_sensors[i], 0);
+	for (i = 0; i < cam_pool->sensor_index; i++) {
+		vidioc_int_dev_exit(cam_pool->all_sensors[i]);
+		vidioc_int_s_power(cam_pool->all_sensors[i], 0);
 	}
 
 	cam_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	vidioc_int_g_fmt_cap(cam->sensor, &cam_fmt);
+	vidioc_int_g_fmt_cap(slave, &cam_fmt);
 
-	/* Used to detect TV in (type 1) vs. camera (type 0)*/
-	cam->device_type = cam_fmt.fmt.pix.priv;
+	for (ain = 0; ain < cam_pool->ain_num; ain++) {
+		cam_data *cam = &cam_pool[ain];
 
-	/* Set the input size to the ipu for this device */
-	cam->crop_bounds.top = cam->crop_bounds.left = 0;
-	cam->crop_bounds.width = cam_fmt.fmt.pix.width;
-	cam->crop_bounds.height = cam_fmt.fmt.pix.height;
+		cam->sensor = slave;
 
-	/* This also is the max crop size for this device. */
-	cam->crop_defrect.top = cam->crop_defrect.left = 0;
-	cam->crop_defrect.width = cam_fmt.fmt.pix.width;
-	cam->crop_defrect.height = cam_fmt.fmt.pix.height;
-
-	/* At this point, this is also the current image size. */
-	cam->crop_current.top = cam->crop_current.left = 0;
-	cam->crop_current.width = cam_fmt.fmt.pix.width;
-	cam->crop_current.height = cam_fmt.fmt.pix.height;
+		/* Used to detect TV in (type 1) vs. camera (type 0)*/
+		cam->device_type = cam_fmt.fmt.pix.priv;
 
-	pr_debug("End of %s: v2f pix widthxheight %d x %d\n",
-		 __func__,
-		 cam->v2f.fmt.pix.width, cam->v2f.fmt.pix.height);
-	pr_debug("End of %s: crop_bounds widthxheight %d x %d\n",
-		 __func__,
-		 cam->crop_bounds.width, cam->crop_bounds.height);
-	pr_debug("End of %s: crop_defrect widthxheight %d x %d\n",
-		 __func__,
-		 cam->crop_defrect.width, cam->crop_defrect.height);
-	pr_debug("End of %s: crop_current widthxheight %d x %d\n",
-		 __func__,
-		 cam->crop_current.width, cam->crop_current.height);
+		/* Set the input size to the ipu for this device */
+		cam->crop_bounds.top = cam->crop_bounds.left = 0;
+		cam->crop_bounds.width = cam_fmt.fmt.pix.width;
+		cam->crop_bounds.height = cam_fmt.fmt.pix.height;
+
+		/* This also is the max crop size for this device. */
+		cam->crop_defrect.top = cam->crop_defrect.left = 0;
+		cam->crop_defrect.width = cam_fmt.fmt.pix.width;
+		cam->crop_defrect.height = cam_fmt.fmt.pix.height;
 
+		/* At this point, this is also the current image size. */
+		cam->crop_current.top = cam->crop_current.left = 0;
+		cam->crop_current.width = cam_fmt.fmt.pix.width;
+		cam->crop_current.height = cam_fmt.fmt.pix.height;
+
+		if (ain == 0) {
+			pr_debug("End of %s: v2f pix widthxheight %d x %d\n",
+				__func__,
+				cam->v2f.fmt.pix.width, cam->v2f.fmt.pix.height);
+			pr_debug("End of %s: crop_bounds widthxheight %d x %d\n",
+				__func__,
+				cam->crop_bounds.width, cam->crop_bounds.height);
+			pr_debug("End of %s: crop_defrect widthxheight %d x %d\n",
+				__func__,
+				cam->crop_defrect.width, cam->crop_defrect.height);
+			pr_debug("End of %s: crop_current widthxheight %d x %d\n",
+				__func__,
+				cam->crop_current.width, cam->crop_current.height);
+		}
+	}
+	
 	return 0;
 }
 
diff -urN fsl/drivers/media/platform/mxc/capture/mxc_v4l2_capture.h sk/drivers/media/platform/mxc/capture/mxc_v4l2_capture.h
--- fsl/drivers/media/platform/mxc/capture/mxc_v4l2_capture.h	2014-09-18 21:48:51.000000000 +0400
+++ sk/drivers/media/platform/mxc/capture/mxc_v4l2_capture.h	2014-10-24 21:56:06.000000000 +0400
@@ -210,6 +210,12 @@
 	bool mclk_on[2];	/* two mclk sources at most now */
 	int current_input;
 
+	int ain_num;
+	int ain_active;
+	int ain;
+	int ain_switch_req;
+	struct work_struct ain_switch_work;
+
 	int local_buf_num;
 
 	/* camera sensor interface */
diff -urN fsl/drivers/mmc/core/sd.c sk/drivers/mmc/core/sd.c
--- fsl/drivers/mmc/core/sd.c	2014-09-18 21:48:51.000000000 +0400
+++ sk/drivers/mmc/core/sd.c	2014-12-06 00:25:13.000000000 +0300
@@ -514,6 +514,13 @@
 	else {
 		mmc_set_timing(card->host, timing);
 		mmc_set_clock(card->host, card->sw_caps.uhs_max_dtr);
+
+		/*
+		 * FIXME: Sandisk SD3.0 cards DDR50 mode requires such
+		 * delay to get stable, without this delay we may encounter
+		 * CRC errors after switch to DDR50 mode
+		 */
+		mmc_delay(100);
 	}
 
 	return 0;
diff -urN fsl/drivers/mxc/ipu3/ipu_common.c sk/drivers/mxc/ipu3/ipu_common.c
--- fsl/drivers/mxc/ipu3/ipu_common.c	2014-09-18 21:48:51.000000000 +0400
+++ sk/drivers/mxc/ipu3/ipu_common.c	2014-10-24 21:56:06.000000000 +0400
@@ -2541,6 +2541,44 @@
 }
 EXPORT_SYMBOL(ipu_disable_csi);
 
+int32_t quick_enable_csi(struct ipu_soc *ipu, uint32_t csi)
+{
+	uint32_t reg;
+
+	if (csi > 1) {
+		dev_err(ipu->dev, "Wrong csi num_%d\n", csi);
+		return -EINVAL;
+	}
+
+	reg = ipu_cm_read(ipu, IPU_CONF);
+	if (csi == 0)
+		ipu_cm_write(ipu, reg | IPU_CONF_CSI0_EN | IPU_CONF_SMFC_EN, IPU_CONF);
+	else
+		ipu_cm_write(ipu, reg | IPU_CONF_CSI1_EN | IPU_CONF_SMFC_EN, IPU_CONF);
+
+	return 0;
+}
+EXPORT_SYMBOL(quick_enable_csi);
+
+int32_t quick_disable_csi(struct ipu_soc *ipu, uint32_t csi)
+{
+	uint32_t reg;
+
+	if (csi > 1) {
+		dev_err(ipu->dev, "Wrong csi num_%d\n", csi);
+		return -EINVAL;
+	}
+
+	reg = ipu_cm_read(ipu, IPU_CONF);
+	if (csi == 0)
+		ipu_cm_write(ipu, reg & ~(IPU_CONF_CSI0_EN | IPU_CONF_SMFC_EN), IPU_CONF);
+	else
+		ipu_cm_write(ipu, reg & ~(IPU_CONF_CSI1_EN | IPU_CONF_SMFC_EN), IPU_CONF);
+
+	return 0;
+}
+EXPORT_SYMBOL(quick_disable_csi);
+
 static irqreturn_t ipu_sync_irq_handler(int irq, void *desc)
 {
 	struct ipu_soc *ipu = desc;
diff -urN fsl/drivers/net/ethernet/realtek/r8169.c sk/drivers/net/ethernet/realtek/r8169.c
--- fsl/drivers/net/ethernet/realtek/r8169.c	2014-09-18 21:48:51.000000000 +0400
+++ sk/drivers/net/ethernet/realtek/r8169.c	2014-10-24 21:56:06.000000000 +0400
@@ -843,8 +843,16 @@
 
 static void rtl_tx_performance_tweak(struct pci_dev *pdev, u16 force)
 {
+#if 0
 	pcie_capability_clear_and_set_word(pdev, PCI_EXP_DEVCTL,
 					   PCI_EXP_DEVCTL_READRQ, force);
+#endif
+	u16 ctl;
+
+	pcie_capability_read_word(pdev, PCI_EXP_DEVCTL, &ctl);
+	dev_info(&pdev->dev, "MRRS = %d, MPS = %d\n", 
+		128 << ((ctl & PCI_EXP_DEVCTL_READRQ) >> 12),
+		128 << ((ctl & PCI_EXP_DEVCTL_PAYLOAD) >> 5));
 }
 
 struct rtl_cond {
diff -urN fsl/drivers/pci/quirks.c sk/drivers/pci/quirks.c
--- fsl/drivers/pci/quirks.c	2014-09-18 21:48:51.000000000 +0400
+++ sk/drivers/pci/quirks.c	2015-02-18 14:16:15.000000000 +0300
@@ -2783,6 +2783,14 @@
 DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_TI, 0xb800,
 				 PCI_CLASS_NOT_DEFINED, 0, fixup_ti816x_class);
 
+static void fixup_tw6869_class(struct pci_dev* dev)
+{
+	dev_info(&dev->dev, "Setting PCI class for tw6868 PCIe device\n");
+	dev->class = PCI_CLASS_MULTIMEDIA_VIDEO;
+}
+DECLARE_PCI_FIXUP_CLASS_EARLY(0x1797, 0x6869, 
+				PCI_CLASS_NOT_DEFINED, 0, fixup_tw6869_class);
+
 /* Some PCIe devices do not work reliably with the claimed maximum
  * payload size supported.
  */
diff -urN fsl/drivers/video/mxc/ldb.c sk/drivers/video/mxc/ldb.c
--- fsl/drivers/video/mxc/ldb.c	2014-09-18 21:48:51.000000000 +0400
+++ sk/drivers/video/mxc/ldb.c	2014-10-24 21:56:06.000000000 +0400
@@ -159,6 +159,14 @@
 	 0,
 	 FB_VMODE_NONINTERLACED,
 	 FB_MODE_IS_DETAILED,},
+	{
+	 "SK-ATM0704", 60, 800, 480, 30000,
+	 220, 40,
+	 21, 7,
+	 60, 10,
+	 0,
+	 FB_VMODE_NONINTERLACED,
+	 FB_MODE_IS_DETAILED,},
 };
 static int ldb_modedb_sz = ARRAY_SIZE(ldb_modedb);
 
diff -urN fsl/drivers/video/mxc/mxc_lcdif.c sk/drivers/video/mxc/mxc_lcdif.c
--- fsl/drivers/video/mxc/mxc_lcdif.c	2014-09-18 21:48:51.000000000 +0400
+++ sk/drivers/video/mxc/mxc_lcdif.c	2014-10-24 21:56:06.000000000 +0400
@@ -48,6 +48,16 @@
 	FB_SYNC_CLK_LAT_FALL,
 	FB_VMODE_NONINTERLACED,
 	0,},
+	{
+	"SK-ATM0704", 60, 800, 480, 29850, 220, 40, 21, 7, 60, 10,
+	FB_SYNC_CLK_LAT_FALL,
+	FB_VMODE_NONINTERLACED,
+	0,},
+	{
+	"SK-MI0430", 60, 480, 272, 150000, 40, 60, 10, 10, 20, 10,
+	FB_SYNC_CLK_LAT_FALL,
+	FB_VMODE_NONINTERLACED,
+	0,},
 };
 static int lcdif_modedb_sz = ARRAY_SIZE(lcdif_modedb);
 
diff -urN fsl/include/linux/ipu-v3.h sk/include/linux/ipu-v3.h
--- fsl/include/linux/ipu-v3.h	2014-09-18 21:48:51.000000000 +0400
+++ sk/include/linux/ipu-v3.h	2014-10-24 21:56:06.000000000 +0400
@@ -638,6 +638,9 @@
 int32_t ipu_enable_csi(struct ipu_soc *ipu, uint32_t csi);
 int32_t ipu_disable_csi(struct ipu_soc *ipu, uint32_t csi);
 
+int32_t quick_enable_csi(struct ipu_soc *ipu, uint32_t csi);
+int32_t quick_disable_csi(struct ipu_soc *ipu, uint32_t csi);
+
 int ipu_lowpwr_display_enable(void);
 int ipu_lowpwr_display_disable(void);
 
diff -urN fsl/sound/soc/fsl/imx-hdmi-dma.c sk/sound/soc/fsl/imx-hdmi-dma.c
--- fsl/sound/soc/fsl/imx-hdmi-dma.c	2014-09-18 21:48:51.000000000 +0400
+++ sk/sound/soc/fsl/imx-hdmi-dma.c	2014-10-24 21:56:06.000000000 +0400
@@ -286,6 +286,7 @@
 	}
 }
 
+#define HDMI_DMA_NO_NEON
 #ifdef HDMI_DMA_NO_NEON
 /* Optimization for IEC head */
 static void hdmi_dma_copy_16_c_lut(u16 *src, u32 *dst, int samples,
diff -urN fsl/sound/soc/fsl/imx-tlv320.c sk/sound/soc/fsl/imx-tlv320.c
--- fsl/sound/soc/fsl/imx-tlv320.c	1970-01-01 03:00:00.000000000 +0300
+++ sk/sound/soc/fsl/imx-tlv320.c	2014-10-24 21:56:07.000000000 +0400
@@ -0,0 +1,221 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2012 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_i2c.h>
+#include <linux/clk.h>
+#include <sound/soc.h>
+
+#include "../codecs/tlv320aic23.h"
+#include "imx-audmux.h"
+
+#define DAI_NAME_SIZE	32
+
+struct imx_tlv320_data {
+	struct snd_soc_dai_link dai;
+	struct snd_soc_card card;
+	char codec_dai_name[DAI_NAME_SIZE];
+	char platform_name[DAI_NAME_SIZE];
+	struct clk *codec_clk;
+	unsigned int clk_frequency;
+};
+
+static int imx_tlv320_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct imx_tlv320_data *data = container_of(rtd->card,
+					struct imx_tlv320_data, card);
+	struct device *dev = rtd->card->dev;
+	int ret;
+
+	ret = snd_soc_dai_set_sysclk(rtd->codec_dai, 0,
+				     data->clk_frequency, SND_SOC_CLOCK_IN);
+	if (ret) {
+		dev_err(dev, "could not set codec driver clock params\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget imx_tlv320_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In", NULL),
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
+};
+
+static int imx_tlv320_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *ssi_np, *codec_np;
+	struct platform_device *ssi_pdev;
+	struct i2c_client *codec_dev;
+	struct imx_tlv320_data *data;
+	int int_port, ext_port;
+	int ret;
+
+	ret = of_property_read_u32(np, "mux-int-port", &int_port);
+	if (ret) {
+		dev_err(&pdev->dev, "mux-int-port missing or invalid\n");
+		return ret;
+	}
+	ret = of_property_read_u32(np, "mux-ext-port", &ext_port);
+	if (ret) {
+		dev_err(&pdev->dev, "mux-ext-port missing or invalid\n");
+		return ret;
+	}
+
+	/*
+	 * The port numbering in the hardware manual starts at 1, while
+	 * the audmux API expects it starts at 0.
+	 */
+	int_port--;
+	ext_port--;
+	ret = imx_audmux_v2_configure_port(int_port,
+			IMX_AUDMUX_V2_PTCR_SYN |
+			IMX_AUDMUX_V2_PTCR_TFSEL(ext_port) |
+			IMX_AUDMUX_V2_PTCR_TCSEL(ext_port) |
+			IMX_AUDMUX_V2_PTCR_TFSDIR |
+			IMX_AUDMUX_V2_PTCR_TCLKDIR,
+			IMX_AUDMUX_V2_PDCR_RXDSEL(ext_port));
+	if (ret) {
+		dev_err(&pdev->dev, "audmux internal port setup failed\n");
+		return ret;
+	}
+	ret = imx_audmux_v2_configure_port(ext_port,
+			IMX_AUDMUX_V2_PTCR_SYN,
+			IMX_AUDMUX_V2_PDCR_RXDSEL(int_port));
+	if (ret) {
+		dev_err(&pdev->dev, "audmux external port setup failed\n");
+		return ret;
+	}
+
+	ssi_np = of_parse_phandle(pdev->dev.of_node, "ssi-controller", 0);
+	codec_np = of_parse_phandle(pdev->dev.of_node, "audio-codec", 0);
+	if (!ssi_np || !codec_np) {
+		dev_err(&pdev->dev, "phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	ssi_pdev = of_find_device_by_node(ssi_np);
+	if (!ssi_pdev) {
+		dev_err(&pdev->dev, "failed to find SSI platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+	codec_dev = of_find_i2c_device_by_node(codec_np);
+	if (!codec_dev) {
+		dev_err(&pdev->dev, "failed to find codec platform device\n");
+		return -EINVAL;
+	}
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	data->codec_clk = clk_get(&codec_dev->dev, NULL);
+	if (IS_ERR(data->codec_clk)) {
+		dev_err(&codec_dev->dev,
+			"codec clock missing or invalid\n");
+		goto fail;
+	}
+
+	ret = of_property_read_u32(codec_np, "clock-frequency",
+			&data->clk_frequency);
+	if (ret)
+		data->clk_frequency = clk_get_rate(data->codec_clk);
+	else
+		clk_set_rate(data->codec_clk, data->clk_frequency);
+
+	dev_info(&codec_dev->dev,
+		"codec clk_frequency = %lu\n", clk_get_rate(data->codec_clk));
+	clk_prepare_enable(data->codec_clk);
+
+	data->dai.name = "tlv320aic23";
+	data->dai.stream_name = "TLV320AIC23";
+	data->dai.codec_dai_name = "tlv320aic23-hifi";
+	data->dai.codec_of_node = codec_np;
+	data->dai.cpu_of_node = ssi_np;
+	data->dai.platform_of_node = ssi_np;
+	data->dai.init = &imx_tlv320_dai_init;
+	data->dai.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			    SND_SOC_DAIFMT_CBM_CFM;
+
+	data->card.dev = &pdev->dev;
+	ret = snd_soc_of_parse_card_name(&data->card, "model");
+	if (ret)
+		goto clk_fail;
+	ret = snd_soc_of_parse_audio_routing(&data->card, "audio-routing");
+	if (ret)
+		goto clk_fail;
+	data->card.num_links = 1;
+	data->card.owner = THIS_MODULE;
+	data->card.dai_link = &data->dai;
+	data->card.dapm_widgets = imx_tlv320_dapm_widgets;
+	data->card.num_dapm_widgets = ARRAY_SIZE(imx_tlv320_dapm_widgets);
+
+	ret = snd_soc_register_card(&data->card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+		goto clk_fail;
+	}
+
+	platform_set_drvdata(pdev, data);
+clk_fail:
+	clk_put(data->codec_clk);
+fail:
+	if (ssi_np)
+		of_node_put(ssi_np);
+	if (codec_np)
+		of_node_put(codec_np);
+
+	return ret;
+}
+
+static int imx_tlv320_remove(struct platform_device *pdev)
+{
+	struct imx_tlv320_data *data = platform_get_drvdata(pdev);
+
+	if (data->codec_clk) {
+		clk_disable_unprepare(data->codec_clk);
+		clk_put(data->codec_clk);
+	}
+	snd_soc_unregister_card(&data->card);
+
+	return 0;
+}
+
+static const struct of_device_id imx_tlv320_dt_ids[] = {
+	{ .compatible = "fsl,imx-audio-tlv320", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_tlv320_dt_ids);
+
+static struct platform_driver imx_tlv320_driver = {
+	.driver = {
+		.name = "imx-tlv320",
+		.owner = THIS_MODULE,
+		.of_match_table = imx_tlv320_dt_ids,
+	},
+	.probe = imx_tlv320_probe,
+	.remove = imx_tlv320_remove,
+};
+module_platform_driver(imx_tlv320_driver);
+
+MODULE_AUTHOR("Starterkit <info@starterkit.ru>");
+MODULE_DESCRIPTION("imx with TLV320AIC23B codec ASoC machine driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:imx-tlv320");
diff -urN fsl/sound/soc/fsl/Kconfig sk/sound/soc/fsl/Kconfig
--- fsl/sound/soc/fsl/Kconfig	2014-09-18 21:48:51.000000000 +0400
+++ sk/sound/soc/fsl/Kconfig	2014-10-24 21:56:07.000000000 +0400
@@ -221,6 +221,18 @@
 	  Say Y if you want to add support for SoC audio on an i.MX board with
 	  a sgtl5000 codec.
 
+config SND_SOC_IMX_TLV320
+	tristate "SoC Audio support for i.MX boards with tlv320aic23"
+	depends on OF && I2C
+	select SND_SOC_TLV320AIC23
+	select SND_SOC_IMX_PCM_DMA
+	select SND_SOC_IMX_AUDMUX
+	select SND_SOC_FSL_SSI
+	select SND_SOC_FSL_UTILS
+	help
+	  Say Y if you want to add support for SoC audio on an i.MX board with
+	  a tlv320aic23 codec.
+
 config SND_SOC_IMX_SPDIF
 	tristate "SoC Audio support for i.MX boards with S/PDIF"
 	select SND_SOC_IMX_PCM_DMA
diff -urN fsl/sound/soc/fsl/Makefile sk/sound/soc/fsl/Makefile
--- fsl/sound/soc/fsl/Makefile	2014-09-18 21:48:51.000000000 +0400
+++ sk/sound/soc/fsl/Makefile	2014-10-24 21:56:07.000000000 +0400
@@ -54,6 +54,7 @@
 snd-soc-wm1133-ev1-objs := wm1133-ev1.o
 snd-soc-imx-cs42888-objs := imx-cs42888.o
 snd-soc-imx-sgtl5000-objs := imx-sgtl5000.o
+snd-soc-imx-tlv320-objs := imx-tlv320.o
 snd-soc-imx-wm8962-objs := imx-wm8962.o
 snd-soc-imx-spdif-objs := imx-spdif.o
 snd-soc-imx-mc13783-objs := imx-mc13783.o
@@ -66,6 +67,7 @@
 obj-$(CONFIG_SND_MXC_SOC_WM1133_EV1) += snd-soc-wm1133-ev1.o
 obj-$(CONFIG_SND_SOC_IMX_CS42888) += snd-soc-imx-cs42888.o
 obj-$(CONFIG_SND_SOC_IMX_SGTL5000) += snd-soc-imx-sgtl5000.o
+obj-$(CONFIG_SND_SOC_IMX_TLV320) += snd-soc-imx-tlv320.o
 obj-$(CONFIG_SND_SOC_IMX_WM8962) += snd-soc-imx-wm8962.o
 obj-$(CONFIG_SND_SOC_IMX_SPDIF) += snd-soc-imx-spdif.o
 obj-$(CONFIG_SND_SOC_IMX_MC13783) += snd-soc-imx-mc13783.o
